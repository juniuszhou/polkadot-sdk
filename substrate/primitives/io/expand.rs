#![feature(prelude_import)]
//! # Substrate Primitives: IO
//!
//! This crate contains interfaces for the runtime to communicate with the outside world, ergo `io`.
//! In other context, such interfaces are referred to as "**host functions**".
//!
//! Each set of host functions are defined with an instance of the
//! [`sp_runtime_interface::runtime_interface`] macro.
//!
//! Most notably, this crate contains host functions for:
//!
//! - [`hashing`]
//! - [`crypto`]
//! - [`trie`]
//! - [`offchain`]
//! - [`storage`]
//! - [`allocator`]
//! - [`logging`]
//!
//! All of the default host functions provided by this crate, and by default contained in all
//! substrate-based clients are amalgamated in [`SubstrateHostFunctions`].
//!
//! ## Externalities
//!
//! Host functions go hand in hand with the concept of externalities. Externalities are an
//! environment in which host functions are provided, and thus can be accessed. Some host functions
//! are only accessible in an externality environment that provides it.
//!
//! A typical error for substrate developers is the following:
//!
//! ```should_panic
//! use sp_io::storage::get;
//! # fn main() {
//! let data = get(b"hello world");
//! # }
//! ```
//!
//! This code will panic with the following error:
//!
//! ```no_compile
//! thread 'main' panicked at '`get_version_1` called outside of an Externalities-provided environment.'
//! ```
//!
//! Such error messages should always be interpreted as "code accessing host functions accessed
//! outside of externalities".
//!
//! An externality is any type that implements [`sp_externalities::Externalities`]. A simple example
//! of which is [`TestExternalities`], which is commonly used in tests and is exported from this
//! crate.
//!
//! ```
//! use sp_io::{storage::get, TestExternalities};
//! # fn main() {
//! TestExternalities::default().execute_with(|| {
//! 	let data = get(b"hello world");
//! });
//! # }
//! ```
#![warn(missing_docs)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use sp_std::vec::Vec;
#[cfg(feature = "std")]
use tracing;
#[cfg(feature = "std")]
use sp_core::{
    crypto::Pair, hexdisplay::HexDisplay,
    offchain::{OffchainDbExt, OffchainWorkerExt, TransactionPoolExt},
    storage::ChildInfo,
};
#[cfg(feature = "std")]
use sp_keystore::KeystoreExt;
use sp_core::{
    crypto::KeyTypeId, ecdsa, ed25519,
    offchain::{
        HttpError, HttpRequestId, HttpRequestStatus, OpaqueNetworkState, StorageKind,
        Timestamp,
    },
    sr25519, storage::StateVersion, LogLevel, LogLevelFilter, OpaquePeerId, H256,
};
#[cfg(feature = "std")]
use sp_trie::{LayoutV0, LayoutV1, TrieConfiguration};
use sp_runtime_interface::{
    pass_by::{PassBy, PassByCodec},
    runtime_interface, Pointer,
};
use codec::{Decode, Encode};
#[cfg(feature = "std")]
use secp256k1::{
    ecdsa::{RecoverableSignature, RecoveryId},
    Message, SECP256K1,
};
#[cfg(feature = "std")]
use sp_externalities::{Externalities, ExternalitiesExt};
pub use sp_externalities::MultiRemovalResults;
#[cfg(feature = "std")]
const LOG_TARGET: &str = "runtime::io";
/// Error verifying ECDSA signature
pub enum EcdsaVerifyError {
    /// Incorrect value of R or S
    BadRS,
    /// Incorrect value of V
    BadV,
    /// Invalid signature
    BadSignature,
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for EcdsaVerifyError {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    EcdsaVerifyError::BadRS => 0_usize,
                    EcdsaVerifyError::BadV => 0_usize,
                    EcdsaVerifyError::BadSignature => 0_usize,
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                EcdsaVerifyError::BadRS => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                }
                EcdsaVerifyError::BadV => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                }
                EcdsaVerifyError::BadSignature => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for EcdsaVerifyError {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for EcdsaVerifyError {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `EcdsaVerifyError`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(EcdsaVerifyError::BadRS)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(EcdsaVerifyError::BadV)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 2usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(EcdsaVerifyError::BadSignature)
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `EcdsaVerifyError`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
/// The outcome of calling `storage_kill`. Returned value is the number of storage items
/// removed from the backend from making the `storage_kill` call.
pub enum KillStorageResult {
    /// All keys to remove were removed, return number of iterations performed during the
    /// operation.
    AllRemoved(u32),
    /// Not all key to remove were removed, return number of iterations performed during the
    /// operation.
    SomeRemaining(u32),
}
const _: () = {
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    impl proc_macro_runtime_interface::pass_by::PassBy for KillStorageResult {
        type PassBy = proc_macro_runtime_interface::pass_by::Codec<KillStorageResult>;
    }
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for KillStorageResult {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    KillStorageResult::AllRemoved(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    KillStorageResult::SomeRemaining(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                KillStorageResult::AllRemoved(ref aa) => {
                    __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                KillStorageResult::SomeRemaining(ref aa) => {
                    __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for KillStorageResult {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for KillStorageResult {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `KillStorageResult`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            KillStorageResult::AllRemoved({
                                let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain("Could not decode `KillStorageResult::AllRemoved.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            KillStorageResult::SomeRemaining({
                                let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e
                                                .chain(
                                                    "Could not decode `KillStorageResult::SomeRemaining.0`",
                                                ),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `KillStorageResult`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
impl From<MultiRemovalResults> for KillStorageResult {
    fn from(r: MultiRemovalResults) -> Self {
        match r.maybe_cursor {
            None => Self::AllRemoved(r.loops),
            Some(..) => Self::SomeRemaining(r.loops),
        }
    }
}
/// Interface for accessing the storage from within the runtime.
pub mod storage {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Append the encoded `value` to the storage item at `key`.
    ///
    /// The storage item needs to implement [`EncodeAppend`](codec::EncodeAppend).
    ///
    /// # Warning
    ///
    /// If the storage item does not support [`EncodeAppend`](codec::EncodeAppend) or
    /// something else fails at appending, the storage item will be set to `[value]`.
    pub fn append(key: &[u8], value: Vec<u8>) {
        append_version_1(key, value)
    }
    #[cfg(feature = "std")]
    /// Always returns `None`. This function exists for compatibility reasons.
    pub fn changes_root(_parent_hash: &[u8]) -> Option<Vec<u8>> {
        changes_root_version_1(_parent_hash)
    }
    #[cfg(feature = "std")]
    /// Clear the storage of the given `key` and its value.
    pub fn clear(key: &[u8]) {
        clear_version_1(key)
    }
    #[cfg(feature = "std")]
    /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
    ///
    /// # Limit
    ///
    /// Deletes all keys from the overlay and up to `limit` keys from the backend if
    /// it is set to `Some`. No limit is applied when `limit` is set to `None`.
    ///
    /// The limit can be used to partially delete a prefix storage in case it is too large
    /// to delete in one go (block).
    ///
    /// Returns [`KillStorageResult`] to inform about the result.
    ///
    /// # Note
    ///
    /// Please note that keys that are residing in the overlay for that prefix when
    /// issuing this call are all deleted without counting towards the `limit`. Only keys
    /// written during the current block are part of the overlay. Deleting with a `limit`
    /// mostly makes sense with an empty overlay for that prefix.
    ///
    /// Calling this function multiple times per block for the same `prefix` does
    /// not make much sense because it is not cumulative when called inside the same block.
    /// The deletion would always start from `prefix` resulting in the same keys being deleted
    /// every time this function is called with the exact same arguments per block. This happens
    /// because the keys in the overlay are not taken into account when deleting keys in the
    /// backend.
    pub fn clear_prefix(prefix: &[u8], limit: Option<u32>) -> KillStorageResult {
        clear_prefix_version_2(prefix, limit)
    }
    #[cfg(feature = "std")]
    /// Commit the last transaction started by `start_transaction`.
    ///
    /// Any changes made during that transaction are committed.
    ///
    /// # Panics
    ///
    /// Will panic if there is no open transaction.
    pub fn commit_transaction() {
        commit_transaction_version_1()
    }
    #[cfg(feature = "std")]
    /// Check whether the given `key` exists in storage.
    pub fn exists(key: &[u8]) -> bool {
        exists_version_1(key)
    }
    #[cfg(feature = "std")]
    /// Returns the data for `key` in the storage or `None` if the key can not be found.
    pub fn get(key: &[u8]) -> Option<bytes::Bytes> {
        get_version_1(key)
    }
    #[cfg(feature = "std")]
    /// Get the next key in storage after the given one in lexicographic order.
    pub fn next_key(key: &[u8]) -> Option<Vec<u8>> {
        next_key_version_1(key)
    }
    #[cfg(feature = "std")]
    /// Get `key` from storage, placing the value into `value_out` and return the number of
    /// bytes that the entry in storage has beyond the offset or `None` if the storage entry
    /// doesn't exist at all.
    /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
    /// are copied into `value_out`.
    pub fn read(key: &[u8], value_out: &mut [u8], value_offset: u32) -> Option<u32> {
        read_version_1(key, value_out, value_offset)
    }
    #[cfg(feature = "std")]
    /// Rollback the last transaction started by `start_transaction`.
    ///
    /// Any changes made during that transaction are discarded.
    ///
    /// # Panics
    ///
    /// Will panic if there is no open transaction.
    pub fn rollback_transaction() {
        rollback_transaction_version_1()
    }
    #[cfg(feature = "std")]
    /// "Commit" all existing operations and compute the resulting storage root.
    ///
    /// The hashing algorithm is defined by the `Block`.
    ///
    /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
    pub fn root(version: StateVersion) -> Vec<u8> {
        root_version_2(version)
    }
    #[cfg(feature = "std")]
    /// Set `key` to `value` in the storage.
    pub fn set(key: &[u8], value: &[u8]) {
        set_version_1(key, value)
    }
    #[cfg(feature = "std")]
    /// Start a new nested transaction.
    ///
    /// This allows to either commit or roll back all changes that are made after this call.
    /// For every transaction there must be a matching call to either `rollback_transaction`
    /// or `commit_transaction`. This is also effective for all values manipulated using the
    /// `DefaultChildStorage` API.
    ///
    /// # Warning
    ///
    /// This is a low level API that is potentially dangerous as it can easily result
    /// in unbalanced transactions. For example, FRAME users should use high level storage
    /// abstractions.
    pub fn start_transaction() {
        start_transaction_version_1()
    }
    #[cfg(feature = "std")]
    /// Append the encoded `value` to the storage item at `key`.
    ///
    /// The storage item needs to implement [`EncodeAppend`](codec::EncodeAppend).
    ///
    /// # Warning
    ///
    /// If the storage item does not support [`EncodeAppend`](codec::EncodeAppend) or
    /// something else fails at appending, the storage item will be set to `[value]`.
    fn append_version_1(key: &[u8], value: Vec<u8>) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "append_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::append_version_1(
                        &mut __externalities__,
                        key,
                        value,
                    ))
                    .expect(
                        "`append_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Always returns `None`. This function exists for compatibility reasons.
    fn changes_root_version_1(_parent_hash: &[u8]) -> Option<Vec<u8>> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "changes_root_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::changes_root_version_1(
                        &mut __externalities__,
                        _parent_hash,
                    ))
                    .expect(
                        "`changes_root_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear the storage of the given `key` and its value.
    fn clear_version_1(key: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::clear_version_1(
                        &mut __externalities__,
                        key,
                    ))
                    .expect(
                        "`clear_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
    fn clear_prefix_version_1(prefix: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_prefix_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::clear_prefix_version_1(
                        &mut __externalities__,
                        prefix,
                    ))
                    .expect(
                        "`clear_prefix_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
    ///
    /// # Limit
    ///
    /// Deletes all keys from the overlay and up to `limit` keys from the backend if
    /// it is set to `Some`. No limit is applied when `limit` is set to `None`.
    ///
    /// The limit can be used to partially delete a prefix storage in case it is too large
    /// to delete in one go (block).
    ///
    /// Returns [`KillStorageResult`] to inform about the result.
    ///
    /// # Note
    ///
    /// Please note that keys that are residing in the overlay for that prefix when
    /// issuing this call are all deleted without counting towards the `limit`. Only keys
    /// written during the current block are part of the overlay. Deleting with a `limit`
    /// mostly makes sense with an empty overlay for that prefix.
    ///
    /// Calling this function multiple times per block for the same `prefix` does
    /// not make much sense because it is not cumulative when called inside the same block.
    /// The deletion would always start from `prefix` resulting in the same keys being deleted
    /// every time this function is called with the exact same arguments per block. This happens
    /// because the keys in the overlay are not taken into account when deleting keys in the
    /// backend.
    fn clear_prefix_version_2(prefix: &[u8], limit: Option<u32>) -> KillStorageResult {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_prefix_version_2",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::clear_prefix_version_2(
                        &mut __externalities__,
                        prefix,
                        limit,
                    ))
                    .expect(
                        "`clear_prefix_version_2` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Partially clear the storage of each key-value pair where the key starts with the given
    /// prefix.
    ///
    /// # Limit
    ///
    /// A *limit* should always be provided through `maybe_limit`. This is one fewer than the
    /// maximum number of backend iterations which may be done by this operation and as such
    /// represents the maximum number of backend deletions which may happen. A *limit* of zero
    /// implies that no keys will be deleted, though there may be a single iteration done.
    ///
    /// The limit can be used to partially delete a prefix storage in case it is too large or costly
    /// to delete in a single operation.
    ///
    /// # Cursor
    ///
    /// A *cursor* may be passed in to this operation with `maybe_cursor`. `None` should only be
    /// passed once (in the initial call) for any given `maybe_prefix` value. Subsequent calls
    /// operating on the same prefix should always pass `Some`, and this should be equal to the
    /// previous call result's `maybe_cursor` field.
    ///
    /// Returns [`MultiRemovalResults`](sp_io::MultiRemovalResults) to inform about the result. Once
    /// the resultant `maybe_cursor` field is `None`, then no further items remain to be deleted.
    ///
    /// NOTE: After the initial call for any given prefix, it is important that no keys further
    /// keys under the same prefix are inserted. If so, then they may or may not be deleted by
    /// subsequent calls.
    ///
    /// # Note
    ///
    /// Please note that keys which are residing in the overlay for that prefix when
    /// issuing this call are deleted without counting towards the `limit`.
    fn clear_prefix_version_3(
        maybe_prefix: &[u8],
        maybe_limit: Option<u32>,
        maybe_cursor: Option<Vec<u8>>,
    ) -> MultiRemovalResults {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_prefix_version_3",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::clear_prefix_version_3(
                        &mut __externalities__,
                        maybe_prefix,
                        maybe_limit,
                        maybe_cursor,
                    ))
                    .expect(
                        "`clear_prefix_version_3` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Commit the last transaction started by `start_transaction`.
    ///
    /// Any changes made during that transaction are committed.
    ///
    /// # Panics
    ///
    /// Will panic if there is no open transaction.
    fn commit_transaction_version_1() {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "commit_transaction_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::commit_transaction_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`commit_transaction_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Check whether the given `key` exists in storage.
    fn exists_version_1(key: &[u8]) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "exists_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::exists_version_1(
                        &mut __externalities__,
                        key,
                    ))
                    .expect(
                        "`exists_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns the data for `key` in the storage or `None` if the key can not be found.
    fn get_version_1(key: &[u8]) -> Option<bytes::Bytes> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::get_version_1(
                        &mut __externalities__,
                        key,
                    ))
                    .expect(
                        "`get_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Get the next key in storage after the given one in lexicographic order.
    fn next_key_version_1(key: &[u8]) -> Option<Vec<u8>> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "next_key_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::next_key_version_1(
                        &mut __externalities__,
                        key,
                    ))
                    .expect(
                        "`next_key_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Get `key` from storage, placing the value into `value_out` and return the number of
    /// bytes that the entry in storage has beyond the offset or `None` if the storage entry
    /// doesn't exist at all.
    /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
    /// are copied into `value_out`.
    fn read_version_1(
        key: &[u8],
        value_out: &mut [u8],
        value_offset: u32,
    ) -> Option<u32> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "read_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::read_version_1(
                        &mut __externalities__,
                        key,
                        value_out,
                        value_offset,
                    ))
                    .expect(
                        "`read_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Rollback the last transaction started by `start_transaction`.
    ///
    /// Any changes made during that transaction are discarded.
    ///
    /// # Panics
    ///
    /// Will panic if there is no open transaction.
    fn rollback_transaction_version_1() {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rollback_transaction_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::rollback_transaction_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`rollback_transaction_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// "Commit" all existing operations and compute the resulting storage root.
    ///
    /// The hashing algorithm is defined by the `Block`.
    ///
    /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
    fn root_version_1() -> Vec<u8> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "root_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::root_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`root_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// "Commit" all existing operations and compute the resulting storage root.
    ///
    /// The hashing algorithm is defined by the `Block`.
    ///
    /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
    fn root_version_2(version: StateVersion) -> Vec<u8> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "root_version_2",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::root_version_2(
                        &mut __externalities__,
                        version,
                    ))
                    .expect(
                        "`root_version_2` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Set `key` to `value` in the storage.
    fn set_version_1(key: &[u8], value: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "set_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::set_version_1(
                        &mut __externalities__,
                        key,
                        value,
                    ))
                    .expect(
                        "`set_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Start a new nested transaction.
    ///
    /// This allows to either commit or roll back all changes that are made after this call.
    /// For every transaction there must be a matching call to either `rollback_transaction`
    /// or `commit_transaction`. This is also effective for all values manipulated using the
    /// `DefaultChildStorage` API.
    ///
    /// # Warning
    ///
    /// This is a low level API that is potentially dangerous as it can easily result
    /// in unbalanced transactions. For example, FRAME users should use high level storage
    /// abstractions.
    fn start_transaction_version_1() {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "start_transaction_version_1",
                        "sp_io::storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(171u32),
                        ::core::option::Option::Some("sp_io::storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Storage::start_transaction_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`start_transaction_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl Storage for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Append the encoded `value` to the storage item at `key`.
        ///
        /// The storage item needs to implement [`EncodeAppend`](codec::EncodeAppend).
        ///
        /// # Warning
        ///
        /// If the storage item does not support [`EncodeAppend`](codec::EncodeAppend) or
        /// something else fails at appending, the storage item will be set to `[value]`.
        fn append_version_1(&mut self, key: &[u8], value: Vec<u8>) {
            self.storage_append(key.to_vec(), value);
        }
        /// Always returns `None`. This function exists for compatibility reasons.
        fn changes_root_version_1(&mut self, _parent_hash: &[u8]) -> Option<Vec<u8>> {
            None
        }
        /// Clear the storage of the given `key` and its value.
        fn clear_version_1(&mut self, key: &[u8]) {
            self.clear_storage(key)
        }
        /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
        fn clear_prefix_version_1(&mut self, prefix: &[u8]) {
            let _ = Externalities::clear_prefix(*self, prefix, None, None);
        }
        /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
        ///
        /// # Limit
        ///
        /// Deletes all keys from the overlay and up to `limit` keys from the backend if
        /// it is set to `Some`. No limit is applied when `limit` is set to `None`.
        ///
        /// The limit can be used to partially delete a prefix storage in case it is too large
        /// to delete in one go (block).
        ///
        /// Returns [`KillStorageResult`] to inform about the result.
        ///
        /// # Note
        ///
        /// Please note that keys that are residing in the overlay for that prefix when
        /// issuing this call are all deleted without counting towards the `limit`. Only keys
        /// written during the current block are part of the overlay. Deleting with a `limit`
        /// mostly makes sense with an empty overlay for that prefix.
        ///
        /// Calling this function multiple times per block for the same `prefix` does
        /// not make much sense because it is not cumulative when called inside the same block.
        /// The deletion would always start from `prefix` resulting in the same keys being deleted
        /// every time this function is called with the exact same arguments per block. This happens
        /// because the keys in the overlay are not taken into account when deleting keys in the
        /// backend.
        fn clear_prefix_version_2(
            &mut self,
            prefix: &[u8],
            limit: Option<u32>,
        ) -> KillStorageResult {
            Externalities::clear_prefix(*self, prefix, limit, None).into()
        }
        /// Partially clear the storage of each key-value pair where the key starts with the given
        /// prefix.
        ///
        /// # Limit
        ///
        /// A *limit* should always be provided through `maybe_limit`. This is one fewer than the
        /// maximum number of backend iterations which may be done by this operation and as such
        /// represents the maximum number of backend deletions which may happen. A *limit* of zero
        /// implies that no keys will be deleted, though there may be a single iteration done.
        ///
        /// The limit can be used to partially delete a prefix storage in case it is too large or costly
        /// to delete in a single operation.
        ///
        /// # Cursor
        ///
        /// A *cursor* may be passed in to this operation with `maybe_cursor`. `None` should only be
        /// passed once (in the initial call) for any given `maybe_prefix` value. Subsequent calls
        /// operating on the same prefix should always pass `Some`, and this should be equal to the
        /// previous call result's `maybe_cursor` field.
        ///
        /// Returns [`MultiRemovalResults`](sp_io::MultiRemovalResults) to inform about the result. Once
        /// the resultant `maybe_cursor` field is `None`, then no further items remain to be deleted.
        ///
        /// NOTE: After the initial call for any given prefix, it is important that no keys further
        /// keys under the same prefix are inserted. If so, then they may or may not be deleted by
        /// subsequent calls.
        ///
        /// # Note
        ///
        /// Please note that keys which are residing in the overlay for that prefix when
        /// issuing this call are deleted without counting towards the `limit`.
        fn clear_prefix_version_3(
            &mut self,
            maybe_prefix: &[u8],
            maybe_limit: Option<u32>,
            maybe_cursor: Option<Vec<u8>>,
        ) -> MultiRemovalResults {
            Externalities::clear_prefix(
                    *self,
                    maybe_prefix,
                    maybe_limit,
                    maybe_cursor.as_ref().map(|x| &x[..]),
                )
                .into()
        }
        /// Commit the last transaction started by `start_transaction`.
        ///
        /// Any changes made during that transaction are committed.
        ///
        /// # Panics
        ///
        /// Will panic if there is no open transaction.
        fn commit_transaction_version_1(&mut self) {
            self.storage_commit_transaction()
                .expect("No open transaction that can be committed.");
        }
        /// Check whether the given `key` exists in storage.
        fn exists_version_1(&self, key: &[u8]) -> bool {
            self.exists_storage(key)
        }
        /// Returns the data for `key` in the storage or `None` if the key can not be found.
        fn get_version_1(&self, key: &[u8]) -> Option<bytes::Bytes> {
            self.storage(key).map(|s| bytes::Bytes::from(s.to_vec()))
        }
        /// Get the next key in storage after the given one in lexicographic order.
        fn next_key_version_1(&mut self, key: &[u8]) -> Option<Vec<u8>> {
            self.next_storage_key(key)
        }
        /// Get `key` from storage, placing the value into `value_out` and return the number of
        /// bytes that the entry in storage has beyond the offset or `None` if the storage entry
        /// doesn't exist at all.
        /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
        /// are copied into `value_out`.
        fn read_version_1(
            &self,
            key: &[u8],
            value_out: &mut [u8],
            value_offset: u32,
        ) -> Option<u32> {
            self.storage(key)
                .map(|value| {
                    let value_offset = value_offset as usize;
                    let data = &value[value_offset.min(value.len())..];
                    let written = std::cmp::min(data.len(), value_out.len());
                    value_out[..written].copy_from_slice(&data[..written]);
                    data.len() as u32
                })
        }
        /// Rollback the last transaction started by `start_transaction`.
        ///
        /// Any changes made during that transaction are discarded.
        ///
        /// # Panics
        ///
        /// Will panic if there is no open transaction.
        fn rollback_transaction_version_1(&mut self) {
            self.storage_rollback_transaction()
                .expect("No open transaction that can be rolled back.");
        }
        /// "Commit" all existing operations and compute the resulting storage root.
        ///
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_1(&mut self) -> Vec<u8> {
            self.storage_root(StateVersion::V0)
        }
        /// "Commit" all existing operations and compute the resulting storage root.
        ///
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_2(&mut self, version: StateVersion) -> Vec<u8> {
            self.storage_root(version)
        }
        /// Set `key` to `value` in the storage.
        fn set_version_1(&mut self, key: &[u8], value: &[u8]) {
            self.set_storage(key.to_vec(), value.to_vec());
        }
        /// Start a new nested transaction.
        ///
        /// This allows to either commit or roll back all changes that are made after this call.
        /// For every transaction there must be a matching call to either `rollback_transaction`
        /// or `commit_transaction`. This is also effective for all values manipulated using the
        /// `DefaultChildStorage` API.
        ///
        /// # Warning
        ///
        /// This is a low level API that is potentially dangerous as it can easily result
        /// in unbalanced transactions. For example, FRAME users should use high level storage
        /// abstractions.
        fn start_transaction_version_1(&mut self) {
            self.storage_start_transaction();
        }
    }
    trait Storage {
        /// Append the encoded `value` to the storage item at `key`.
        ///
        /// The storage item needs to implement [`EncodeAppend`](codec::EncodeAppend).
        ///
        /// # Warning
        ///
        /// If the storage item does not support [`EncodeAppend`](codec::EncodeAppend) or
        /// something else fails at appending, the storage item will be set to `[value]`.
        fn append_version_1(&mut self, key: &[u8], value: Vec<u8>);
        /// Always returns `None`. This function exists for compatibility reasons.
        fn changes_root_version_1(&mut self, _parent_hash: &[u8]) -> Option<Vec<u8>>;
        /// Clear the storage of the given `key` and its value.
        fn clear_version_1(&mut self, key: &[u8]);
        /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
        fn clear_prefix_version_1(&mut self, prefix: &[u8]);
        /// Clear the storage of each key-value pair where the key starts with the given `prefix`.
        ///
        /// # Limit
        ///
        /// Deletes all keys from the overlay and up to `limit` keys from the backend if
        /// it is set to `Some`. No limit is applied when `limit` is set to `None`.
        ///
        /// The limit can be used to partially delete a prefix storage in case it is too large
        /// to delete in one go (block).
        ///
        /// Returns [`KillStorageResult`] to inform about the result.
        ///
        /// # Note
        ///
        /// Please note that keys that are residing in the overlay for that prefix when
        /// issuing this call are all deleted without counting towards the `limit`. Only keys
        /// written during the current block are part of the overlay. Deleting with a `limit`
        /// mostly makes sense with an empty overlay for that prefix.
        ///
        /// Calling this function multiple times per block for the same `prefix` does
        /// not make much sense because it is not cumulative when called inside the same block.
        /// The deletion would always start from `prefix` resulting in the same keys being deleted
        /// every time this function is called with the exact same arguments per block. This happens
        /// because the keys in the overlay are not taken into account when deleting keys in the
        /// backend.
        fn clear_prefix_version_2(
            &mut self,
            prefix: &[u8],
            limit: Option<u32>,
        ) -> KillStorageResult;
        /// Partially clear the storage of each key-value pair where the key starts with the given
        /// prefix.
        ///
        /// # Limit
        ///
        /// A *limit* should always be provided through `maybe_limit`. This is one fewer than the
        /// maximum number of backend iterations which may be done by this operation and as such
        /// represents the maximum number of backend deletions which may happen. A *limit* of zero
        /// implies that no keys will be deleted, though there may be a single iteration done.
        ///
        /// The limit can be used to partially delete a prefix storage in case it is too large or costly
        /// to delete in a single operation.
        ///
        /// # Cursor
        ///
        /// A *cursor* may be passed in to this operation with `maybe_cursor`. `None` should only be
        /// passed once (in the initial call) for any given `maybe_prefix` value. Subsequent calls
        /// operating on the same prefix should always pass `Some`, and this should be equal to the
        /// previous call result's `maybe_cursor` field.
        ///
        /// Returns [`MultiRemovalResults`](sp_io::MultiRemovalResults) to inform about the result. Once
        /// the resultant `maybe_cursor` field is `None`, then no further items remain to be deleted.
        ///
        /// NOTE: After the initial call for any given prefix, it is important that no keys further
        /// keys under the same prefix are inserted. If so, then they may or may not be deleted by
        /// subsequent calls.
        ///
        /// # Note
        ///
        /// Please note that keys which are residing in the overlay for that prefix when
        /// issuing this call are deleted without counting towards the `limit`.
        fn clear_prefix_version_3(
            &mut self,
            maybe_prefix: &[u8],
            maybe_limit: Option<u32>,
            maybe_cursor: Option<Vec<u8>>,
        ) -> MultiRemovalResults;
        /// Commit the last transaction started by `start_transaction`.
        ///
        /// Any changes made during that transaction are committed.
        ///
        /// # Panics
        ///
        /// Will panic if there is no open transaction.
        fn commit_transaction_version_1(&mut self);
        /// Check whether the given `key` exists in storage.
        fn exists_version_1(&self, key: &[u8]) -> bool;
        /// Returns the data for `key` in the storage or `None` if the key can not be found.
        fn get_version_1(&self, key: &[u8]) -> Option<bytes::Bytes>;
        /// Get the next key in storage after the given one in lexicographic order.
        fn next_key_version_1(&mut self, key: &[u8]) -> Option<Vec<u8>>;
        /// Get `key` from storage, placing the value into `value_out` and return the number of
        /// bytes that the entry in storage has beyond the offset or `None` if the storage entry
        /// doesn't exist at all.
        /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
        /// are copied into `value_out`.
        fn read_version_1(
            &self,
            key: &[u8],
            value_out: &mut [u8],
            value_offset: u32,
        ) -> Option<u32>;
        /// Rollback the last transaction started by `start_transaction`.
        ///
        /// Any changes made during that transaction are discarded.
        ///
        /// # Panics
        ///
        /// Will panic if there is no open transaction.
        fn rollback_transaction_version_1(&mut self);
        /// "Commit" all existing operations and compute the resulting storage root.
        ///
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_1(&mut self) -> Vec<u8>;
        /// "Commit" all existing operations and compute the resulting storage root.
        ///
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_2(&mut self, version: StateVersion) -> Vec<u8>;
        /// Set `key` to `value` in the storage.
        fn set_version_1(&mut self, key: &[u8], value: &[u8]);
        /// Start a new nested transaction.
        ///
        /// This allows to either commit or roll back all changes that are made after this call.
        /// For every transaction there must be a matching call to either `rollback_transaction`
        /// or `commit_transaction`. This is also effective for all values manipulated using the
        /// `DefaultChildStorage` API.
        ///
        /// # Warning
        ///
        /// This is a low level API that is potentially dangerous as it can easily result
        /// in unbalanced transactions. For example, FRAME users should use high level storage
        /// abstractions.
        fn start_transaction_version_1(&mut self);
    }
    #[cfg(feature = "std")]
    struct ExtStorageAppendVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageAppendVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'append' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut value = <Vec<
                u8,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'append' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = append_version_1(&key, value);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageAppendVersion1 {
        fn name(&self) -> &str {
            "ext_storage_append_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Vec<
                            u8,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'append' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'append' from interface 'Storage'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'append' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <Vec<
                u8,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'append' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageChangesRootVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageChangesRootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            _parent_hash_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<Vec<u8>> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut _parent_hash = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    _parent_hash_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the '_parent_hash' argument through the WASM FFI boundary while executing 'changes_root' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = changes_root_version_1(&_parent_hash);
            let __result__ = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageChangesRootVersion1 {
        fn name(&self) -> &str {
            "ext_storage_changes_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        Vec<u8>,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let _parent_hash_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument '_parent_hash': number of arguments given to 'changes_root' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let _parent_hash_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    _parent_hash_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the '_parent_hash' argument through the WASM FFI boundary while executing 'changes_root' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, _parent_hash_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageClearVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageClearVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'clear' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_version_1(&key);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageClearVersion1 {
        fn name(&self) -> &str {
            "ext_storage_clear_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'clear' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'clear' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, key_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageClearPrefixVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageClearPrefixVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut prefix = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    prefix_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_prefix_version_1(&prefix);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageClearPrefixVersion1 {
        fn name(&self) -> &str {
            "ext_storage_clear_prefix_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let prefix_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'prefix': number of arguments given to 'clear_prefix' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    prefix_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, prefix_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageClearPrefixVersion2;
    #[cfg(feature = "std")]
    impl ExtStorageClearPrefixVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut prefix = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    prefix_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_prefix_version_2(&prefix, limit);
            let __result__ = <KillStorageResult as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageClearPrefixVersion2 {
        fn name(&self) -> &str {
            "ext_storage_clear_prefix_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let prefix_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'prefix': number of arguments given to 'clear_prefix' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    prefix_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'"
                        .to_owned()
                })?;
            let limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'limit': number of arguments given to 'clear_prefix' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                prefix_ffi_value,
                limit_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageClearPrefixVersion3;
    #[cfg(feature = "std")]
    impl ExtStorageClearPrefixVersion3 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            maybe_prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            maybe_limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            maybe_cursor_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut maybe_prefix = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_prefix_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut maybe_limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut maybe_cursor = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_cursor_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_cursor' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_prefix_version_3(
                &maybe_prefix,
                maybe_limit,
                maybe_cursor,
            );
            let __result__ = <MultiRemovalResults as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageClearPrefixVersion3 {
        fn name(&self) -> &str {
            "ext_storage_clear_prefix_version_3"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let maybe_prefix_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_prefix': number of arguments given to 'clear_prefix' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_prefix_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'"
                        .to_owned()
                })?;
            let maybe_limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_limit': number of arguments given to 'clear_prefix' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'"
                        .to_owned()
                })?;
            let maybe_cursor_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_cursor': number of arguments given to 'clear_prefix' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_cursor_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_cursor_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_cursor' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                maybe_prefix_ffi_value,
                maybe_limit_ffi_value,
                maybe_cursor_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageCommitTransactionVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageCommitTransactionVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<(), String> {
            let __result__ = commit_transaction_version_1();
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageCommitTransactionVersion1 {
        fn name(&self) -> &str {
            "ext_storage_commit_transaction_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageExistsVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageExistsVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'exists' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = exists_version_1(&key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageExistsVersion1 {
        fn name(&self) -> &str {
            "ext_storage_exists_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'exists' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'exists' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, key_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageGetVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageGetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<bytes::Bytes> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'get' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = get_version_1(&key);
            let __result__ = <Option<
                bytes::Bytes,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageGetVersion1 {
        fn name(&self) -> &str {
            "ext_storage_get_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        bytes::Bytes,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'get' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'get' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, key_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageNextKeyVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageNextKeyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<Vec<u8>> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'next_key' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = next_key_version_1(&key);
            let __result__ = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageNextKeyVersion1 {
        fn name(&self) -> &str {
            "ext_storage_next_key_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        Vec<u8>,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'next_key' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'next_key' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, key_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageReadVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageReadVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_out_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_offset_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<u32> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'read' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut value_out = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_out_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value_out' argument through the WASM FFI boundary while executing 'read' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut value_offset = <u32 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_offset_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value_offset' argument through the WASM FFI boundary while executing 'read' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = read_version_1(&key, &mut value_out, value_offset);
            <[u8] as proc_macro_runtime_interface::host::IntoPreallocatedFFIValue>::into_preallocated_ffi_value(
                value_out,
                __function_context__,
                value_out_ffi_value,
            )?;
            let __result__ = <Option<
                u32,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageReadVersion1 {
        fn name(&self) -> &str {
            "ext_storage_read_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<u32 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        u32,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'read' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'read' from interface 'Storage'"
                        .to_owned()
                })?;
            let value_out_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value_out': number of arguments given to 'read' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_out_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_out_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value_out' argument through the WASM FFI boundary while executing 'read' from interface 'Storage'"
                        .to_owned()
                })?;
            let value_offset_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value_offset': number of arguments given to 'read' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_offset_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_offset_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value_offset' argument through the WASM FFI boundary while executing 'read' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                key_ffi_value,
                value_out_ffi_value,
                value_offset_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageRollbackTransactionVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageRollbackTransactionVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<(), String> {
            let __result__ = rollback_transaction_version_1();
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageRollbackTransactionVersion1 {
        fn name(&self) -> &str {
            "ext_storage_rollback_transaction_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageRootVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageRootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = root_version_1();
            let __result__ = <Vec<
                u8,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageRootVersion1 {
        fn name(&self) -> &str {
            "ext_storage_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<Vec<
                        u8,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageRootVersion2;
    #[cfg(feature = "std")]
    impl ExtStorageRootVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'root' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = root_version_2(version);
            let __result__ = <Vec<
                u8,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageRootVersion2 {
        fn name(&self) -> &str {
            "ext_storage_root_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        u8,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'root' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'root' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, version_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageSetVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageSetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'set' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'set' from interface 'Storage'",
                        ),
                    );
                    res
                })?;
            let __result__ = set_version_1(&key, &value);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageSetVersion1 {
        fn name(&self) -> &str {
            "ext_storage_set_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'set' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'set' from interface 'Storage'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'set' from interface 'Storage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'set' from interface 'Storage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtStorageStartTransactionVersion1;
    #[cfg(feature = "std")]
    impl ExtStorageStartTransactionVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<(), String> {
            let __result__ = start_transaction_version_1();
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtStorageStartTransactionVersion1 {
        fn name(&self) -> &str {
            "ext_storage_start_transaction_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtStorageAppendVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageChangesRootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageClearVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageClearPrefixVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageClearPrefixVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageClearPrefixVersion3
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageCommitTransactionVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageExistsVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageGetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageNextKeyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageReadVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageRollbackTransactionVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageRootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageRootVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageSetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtStorageStartTransactionVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageAppendVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <Vec<
                            u8,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageAppendVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageChangesRootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        _parent_hash_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageChangesRootVersion1::call(
                                                __function_context__,
                                                _parent_hash_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageClearVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageClearVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageClearPrefixVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageClearPrefixVersion1::call(
                                                __function_context__,
                                                prefix_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageClearPrefixVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageClearPrefixVersion2::call(
                                                __function_context__,
                                                prefix_ffi_value,
                                                limit_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageClearPrefixVersion3,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        maybe_prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        maybe_limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        maybe_cursor_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageClearPrefixVersion3::call(
                                                __function_context__,
                                                maybe_prefix_ffi_value,
                                                maybe_limit_ffi_value,
                                                maybe_cursor_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageCommitTransactionVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageCommitTransactionVersion1::call(
                                                __function_context__,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageExistsVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageExistsVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageGetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            bytes::Bytes,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageGetVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageNextKeyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageNextKeyVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageReadVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_out_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_offset_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<u32> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageReadVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                                value_out_ffi_value,
                                                value_offset_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageRollbackTransactionVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageRollbackTransactionVersion1::call(
                                                __function_context__,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageRootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageRootVersion1::call(__function_context__)
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageRootVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageRootVersion2::call(
                                                __function_context__,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageSetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageSetVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtStorageStartTransactionVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtStorageStartTransactionVersion1::call(
                                                __function_context__,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface for accessing the child storage for default child trie,
/// from within the runtime.
pub mod default_child_storage {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Clear a child storage key.
    ///
    /// For the default child storage at `storage_key`, clear value at `key`.
    pub fn clear(storage_key: &[u8], key: &[u8]) {
        clear_version_1(storage_key, key)
    }
    #[cfg(feature = "std")]
    /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    pub fn clear_prefix(
        storage_key: &[u8],
        prefix: &[u8],
        limit: Option<u32>,
    ) -> KillStorageResult {
        clear_prefix_version_2(storage_key, prefix, limit)
    }
    #[cfg(feature = "std")]
    /// Check a child storage key.
    ///
    /// Check whether the given `key` exists in default child defined at `storage_key`.
    pub fn exists(storage_key: &[u8], key: &[u8]) -> bool {
        exists_version_1(storage_key, key)
    }
    #[cfg(feature = "std")]
    /// Get a default child storage value for a given key.
    ///
    /// Parameter `storage_key` is the unprefixed location of the root of the child trie in the
    /// parent trie. Result is `None` if the value for `key` in the child storage can not be found.
    pub fn get(storage_key: &[u8], key: &[u8]) -> Option<Vec<u8>> {
        get_version_1(storage_key, key)
    }
    #[cfg(feature = "std")]
    /// Child storage key iteration.
    ///
    /// Get the next key in storage after the given one in lexicographic order in child storage.
    pub fn next_key(storage_key: &[u8], key: &[u8]) -> Option<Vec<u8>> {
        next_key_version_1(storage_key, key)
    }
    #[cfg(feature = "std")]
    /// Allocation efficient variant of `get`.
    ///
    /// Get `key` from child storage, placing the value into `value_out` and return the number
    /// of bytes that the entry in storage has beyond the offset or `None` if the storage entry
    /// doesn't exist at all.
    /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
    /// are copied into `value_out`.
    pub fn read(
        storage_key: &[u8],
        key: &[u8],
        value_out: &mut [u8],
        value_offset: u32,
    ) -> Option<u32> {
        read_version_1(storage_key, key, value_out, value_offset)
    }
    #[cfg(feature = "std")]
    /// Default child root calculation.
    ///
    /// "Commit" all existing operations and compute the resulting child storage root.
    /// The hashing algorithm is defined by the `Block`.
    ///
    /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
    pub fn root(storage_key: &[u8], version: StateVersion) -> Vec<u8> {
        root_version_2(storage_key, version)
    }
    #[cfg(feature = "std")]
    /// Set a child storage value.
    ///
    /// Set `key` to `value` in the child storage denoted by `storage_key`.
    pub fn set(storage_key: &[u8], key: &[u8], value: &[u8]) {
        set_version_1(storage_key, key, value)
    }
    #[cfg(feature = "std")]
    /// Clear a child storage key.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    pub fn storage_kill(storage_key: &[u8], limit: Option<u32>) -> KillStorageResult {
        storage_kill_version_3(storage_key, limit)
    }
    #[cfg(feature = "std")]
    /// Clear a child storage key.
    ///
    /// For the default child storage at `storage_key`, clear value at `key`.
    fn clear_version_1(storage_key: &[u8], key: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::clear_version_1(
                        &mut __externalities__,
                        storage_key,
                        key,
                    ))
                    .expect(
                        "`clear_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear child default key by prefix.
    ///
    /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
    fn clear_prefix_version_1(storage_key: &[u8], prefix: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_prefix_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::clear_prefix_version_1(
                        &mut __externalities__,
                        storage_key,
                        prefix,
                    ))
                    .expect(
                        "`clear_prefix_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    fn clear_prefix_version_2(
        storage_key: &[u8],
        prefix: &[u8],
        limit: Option<u32>,
    ) -> KillStorageResult {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_prefix_version_2",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::clear_prefix_version_2(
                        &mut __externalities__,
                        storage_key,
                        prefix,
                        limit,
                    ))
                    .expect(
                        "`clear_prefix_version_2` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    fn clear_prefix_version_3(
        storage_key: &[u8],
        prefix: &[u8],
        maybe_limit: Option<u32>,
        maybe_cursor: Option<Vec<u8>>,
    ) -> MultiRemovalResults {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_prefix_version_3",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::clear_prefix_version_3(
                        &mut __externalities__,
                        storage_key,
                        prefix,
                        maybe_limit,
                        maybe_cursor,
                    ))
                    .expect(
                        "`clear_prefix_version_3` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Check a child storage key.
    ///
    /// Check whether the given `key` exists in default child defined at `storage_key`.
    fn exists_version_1(storage_key: &[u8], key: &[u8]) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "exists_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::exists_version_1(
                        &mut __externalities__,
                        storage_key,
                        key,
                    ))
                    .expect(
                        "`exists_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Get a default child storage value for a given key.
    ///
    /// Parameter `storage_key` is the unprefixed location of the root of the child trie in the
    /// parent trie. Result is `None` if the value for `key` in the child storage can not be found.
    fn get_version_1(storage_key: &[u8], key: &[u8]) -> Option<Vec<u8>> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::get_version_1(
                        &mut __externalities__,
                        storage_key,
                        key,
                    ))
                    .expect(
                        "`get_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Child storage key iteration.
    ///
    /// Get the next key in storage after the given one in lexicographic order in child storage.
    fn next_key_version_1(storage_key: &[u8], key: &[u8]) -> Option<Vec<u8>> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "next_key_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::next_key_version_1(
                        &mut __externalities__,
                        storage_key,
                        key,
                    ))
                    .expect(
                        "`next_key_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Allocation efficient variant of `get`.
    ///
    /// Get `key` from child storage, placing the value into `value_out` and return the number
    /// of bytes that the entry in storage has beyond the offset or `None` if the storage entry
    /// doesn't exist at all.
    /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
    /// are copied into `value_out`.
    fn read_version_1(
        storage_key: &[u8],
        key: &[u8],
        value_out: &mut [u8],
        value_offset: u32,
    ) -> Option<u32> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "read_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::read_version_1(
                        &mut __externalities__,
                        storage_key,
                        key,
                        value_out,
                        value_offset,
                    ))
                    .expect(
                        "`read_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Default child root calculation.
    ///
    /// "Commit" all existing operations and compute the resulting child storage root.
    /// The hashing algorithm is defined by the `Block`.
    ///
    /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
    fn root_version_1(storage_key: &[u8]) -> Vec<u8> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "root_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::root_version_1(
                        &mut __externalities__,
                        storage_key,
                    ))
                    .expect(
                        "`root_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Default child root calculation.
    ///
    /// "Commit" all existing operations and compute the resulting child storage root.
    /// The hashing algorithm is defined by the `Block`.
    ///
    /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
    fn root_version_2(storage_key: &[u8], version: StateVersion) -> Vec<u8> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "root_version_2",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::root_version_2(
                        &mut __externalities__,
                        storage_key,
                        version,
                    ))
                    .expect(
                        "`root_version_2` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Set a child storage value.
    ///
    /// Set `key` to `value` in the child storage denoted by `storage_key`.
    fn set_version_1(storage_key: &[u8], key: &[u8], value: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "set_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::set_version_1(
                        &mut __externalities__,
                        storage_key,
                        key,
                        value,
                    ))
                    .expect(
                        "`set_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear an entire child storage.
    ///
    /// If it exists, the child storage for `storage_key`
    /// is removed.
    fn storage_kill_version_1(storage_key: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "storage_kill_version_1",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::storage_kill_version_1(
                        &mut __externalities__,
                        storage_key,
                    ))
                    .expect(
                        "`storage_kill_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear a child storage key.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    fn storage_kill_version_2(storage_key: &[u8], limit: Option<u32>) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "storage_kill_version_2",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::storage_kill_version_2(
                        &mut __externalities__,
                        storage_key,
                        limit,
                    ))
                    .expect(
                        "`storage_kill_version_2` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear a child storage key.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    fn storage_kill_version_3(
        storage_key: &[u8],
        limit: Option<u32>,
    ) -> KillStorageResult {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "storage_kill_version_3",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::storage_kill_version_3(
                        &mut __externalities__,
                        storage_key,
                        limit,
                    ))
                    .expect(
                        "`storage_kill_version_3` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Clear a child storage key.
    ///
    /// See `Storage` module `clear_prefix` documentation for `limit` usage.
    fn storage_kill_version_4(
        storage_key: &[u8],
        maybe_limit: Option<u32>,
        maybe_cursor: Option<Vec<u8>>,
    ) -> MultiRemovalResults {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "storage_kill_version_4",
                        "sp_io::default_child_storage",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(374u32),
                        ::core::option::Option::Some("sp_io::default_child_storage"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| DefaultChildStorage::storage_kill_version_4(
                        &mut __externalities__,
                        storage_key,
                        maybe_limit,
                        maybe_cursor,
                    ))
                    .expect(
                        "`storage_kill_version_4` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl DefaultChildStorage for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Clear a child storage key.
        ///
        /// For the default child storage at `storage_key`, clear value at `key`.
        fn clear_version_1(&mut self, storage_key: &[u8], key: &[u8]) {
            let child_info = ChildInfo::new_default(storage_key);
            self.clear_child_storage(&child_info, key);
        }
        /// Clear child default key by prefix.
        ///
        /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
        fn clear_prefix_version_1(&mut self, storage_key: &[u8], prefix: &[u8]) {
            let child_info = ChildInfo::new_default(storage_key);
            let _ = self.clear_child_prefix(&child_info, prefix, None, None);
        }
        /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn clear_prefix_version_2(
            &mut self,
            storage_key: &[u8],
            prefix: &[u8],
            limit: Option<u32>,
        ) -> KillStorageResult {
            let child_info = ChildInfo::new_default(storage_key);
            self.clear_child_prefix(&child_info, prefix, limit, None).into()
        }
        /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn clear_prefix_version_3(
            &mut self,
            storage_key: &[u8],
            prefix: &[u8],
            maybe_limit: Option<u32>,
            maybe_cursor: Option<Vec<u8>>,
        ) -> MultiRemovalResults {
            let child_info = ChildInfo::new_default(storage_key);
            self.clear_child_prefix(
                    &child_info,
                    prefix,
                    maybe_limit,
                    maybe_cursor.as_ref().map(|x| &x[..]),
                )
                .into()
        }
        /// Check a child storage key.
        ///
        /// Check whether the given `key` exists in default child defined at `storage_key`.
        fn exists_version_1(&self, storage_key: &[u8], key: &[u8]) -> bool {
            let child_info = ChildInfo::new_default(storage_key);
            self.exists_child_storage(&child_info, key)
        }
        /// Get a default child storage value for a given key.
        ///
        /// Parameter `storage_key` is the unprefixed location of the root of the child trie in the
        /// parent trie. Result is `None` if the value for `key` in the child storage can not be found.
        fn get_version_1(&self, storage_key: &[u8], key: &[u8]) -> Option<Vec<u8>> {
            let child_info = ChildInfo::new_default(storage_key);
            self.child_storage(&child_info, key).map(|s| s.to_vec())
        }
        /// Child storage key iteration.
        ///
        /// Get the next key in storage after the given one in lexicographic order in child storage.
        fn next_key_version_1(
            &mut self,
            storage_key: &[u8],
            key: &[u8],
        ) -> Option<Vec<u8>> {
            let child_info = ChildInfo::new_default(storage_key);
            self.next_child_storage_key(&child_info, key)
        }
        /// Allocation efficient variant of `get`.
        ///
        /// Get `key` from child storage, placing the value into `value_out` and return the number
        /// of bytes that the entry in storage has beyond the offset or `None` if the storage entry
        /// doesn't exist at all.
        /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
        /// are copied into `value_out`.
        fn read_version_1(
            &self,
            storage_key: &[u8],
            key: &[u8],
            value_out: &mut [u8],
            value_offset: u32,
        ) -> Option<u32> {
            let child_info = ChildInfo::new_default(storage_key);
            self.child_storage(&child_info, key)
                .map(|value| {
                    let value_offset = value_offset as usize;
                    let data = &value[value_offset.min(value.len())..];
                    let written = std::cmp::min(data.len(), value_out.len());
                    value_out[..written].copy_from_slice(&data[..written]);
                    data.len() as u32
                })
        }
        /// Default child root calculation.
        ///
        /// "Commit" all existing operations and compute the resulting child storage root.
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_1(&mut self, storage_key: &[u8]) -> Vec<u8> {
            let child_info = ChildInfo::new_default(storage_key);
            self.child_storage_root(&child_info, StateVersion::V0)
        }
        /// Default child root calculation.
        ///
        /// "Commit" all existing operations and compute the resulting child storage root.
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_2(
            &mut self,
            storage_key: &[u8],
            version: StateVersion,
        ) -> Vec<u8> {
            let child_info = ChildInfo::new_default(storage_key);
            self.child_storage_root(&child_info, version)
        }
        /// Set a child storage value.
        ///
        /// Set `key` to `value` in the child storage denoted by `storage_key`.
        fn set_version_1(&mut self, storage_key: &[u8], key: &[u8], value: &[u8]) {
            let child_info = ChildInfo::new_default(storage_key);
            self.set_child_storage(&child_info, key.to_vec(), value.to_vec());
        }
        /// Clear an entire child storage.
        ///
        /// If it exists, the child storage for `storage_key`
        /// is removed.
        fn storage_kill_version_1(&mut self, storage_key: &[u8]) {
            let child_info = ChildInfo::new_default(storage_key);
            let _ = self.kill_child_storage(&child_info, None, None);
        }
        /// Clear a child storage key.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn storage_kill_version_2(
            &mut self,
            storage_key: &[u8],
            limit: Option<u32>,
        ) -> bool {
            let child_info = ChildInfo::new_default(storage_key);
            let r = self.kill_child_storage(&child_info, limit, None);
            r.maybe_cursor.is_none()
        }
        /// Clear a child storage key.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn storage_kill_version_3(
            &mut self,
            storage_key: &[u8],
            limit: Option<u32>,
        ) -> KillStorageResult {
            let child_info = ChildInfo::new_default(storage_key);
            self.kill_child_storage(&child_info, limit, None).into()
        }
        /// Clear a child storage key.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn storage_kill_version_4(
            &mut self,
            storage_key: &[u8],
            maybe_limit: Option<u32>,
            maybe_cursor: Option<Vec<u8>>,
        ) -> MultiRemovalResults {
            let child_info = ChildInfo::new_default(storage_key);
            self.kill_child_storage(
                    &child_info,
                    maybe_limit,
                    maybe_cursor.as_ref().map(|x| &x[..]),
                )
                .into()
        }
    }
    trait DefaultChildStorage {
        /// Clear a child storage key.
        ///
        /// For the default child storage at `storage_key`, clear value at `key`.
        fn clear_version_1(&mut self, storage_key: &[u8], key: &[u8]);
        /// Clear child default key by prefix.
        ///
        /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
        fn clear_prefix_version_1(&mut self, storage_key: &[u8], prefix: &[u8]);
        /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn clear_prefix_version_2(
            &mut self,
            storage_key: &[u8],
            prefix: &[u8],
            limit: Option<u32>,
        ) -> KillStorageResult;
        /// Clear the child storage of each key-value pair where the key starts with the given `prefix`.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn clear_prefix_version_3(
            &mut self,
            storage_key: &[u8],
            prefix: &[u8],
            maybe_limit: Option<u32>,
            maybe_cursor: Option<Vec<u8>>,
        ) -> MultiRemovalResults;
        /// Check a child storage key.
        ///
        /// Check whether the given `key` exists in default child defined at `storage_key`.
        fn exists_version_1(&self, storage_key: &[u8], key: &[u8]) -> bool;
        /// Get a default child storage value for a given key.
        ///
        /// Parameter `storage_key` is the unprefixed location of the root of the child trie in the
        /// parent trie. Result is `None` if the value for `key` in the child storage can not be found.
        fn get_version_1(&self, storage_key: &[u8], key: &[u8]) -> Option<Vec<u8>>;
        /// Child storage key iteration.
        ///
        /// Get the next key in storage after the given one in lexicographic order in child storage.
        fn next_key_version_1(
            &mut self,
            storage_key: &[u8],
            key: &[u8],
        ) -> Option<Vec<u8>>;
        /// Allocation efficient variant of `get`.
        ///
        /// Get `key` from child storage, placing the value into `value_out` and return the number
        /// of bytes that the entry in storage has beyond the offset or `None` if the storage entry
        /// doesn't exist at all.
        /// If `value_out` length is smaller than the returned length, only `value_out` length bytes
        /// are copied into `value_out`.
        fn read_version_1(
            &self,
            storage_key: &[u8],
            key: &[u8],
            value_out: &mut [u8],
            value_offset: u32,
        ) -> Option<u32>;
        /// Default child root calculation.
        ///
        /// "Commit" all existing operations and compute the resulting child storage root.
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_1(&mut self, storage_key: &[u8]) -> Vec<u8>;
        /// Default child root calculation.
        ///
        /// "Commit" all existing operations and compute the resulting child storage root.
        /// The hashing algorithm is defined by the `Block`.
        ///
        /// Returns a `Vec<u8>` that holds the SCALE encoded hash.
        fn root_version_2(
            &mut self,
            storage_key: &[u8],
            version: StateVersion,
        ) -> Vec<u8>;
        /// Set a child storage value.
        ///
        /// Set `key` to `value` in the child storage denoted by `storage_key`.
        fn set_version_1(&mut self, storage_key: &[u8], key: &[u8], value: &[u8]);
        /// Clear an entire child storage.
        ///
        /// If it exists, the child storage for `storage_key`
        /// is removed.
        fn storage_kill_version_1(&mut self, storage_key: &[u8]);
        /// Clear a child storage key.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn storage_kill_version_2(
            &mut self,
            storage_key: &[u8],
            limit: Option<u32>,
        ) -> bool;
        /// Clear a child storage key.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn storage_kill_version_3(
            &mut self,
            storage_key: &[u8],
            limit: Option<u32>,
        ) -> KillStorageResult;
        /// Clear a child storage key.
        ///
        /// See `Storage` module `clear_prefix` documentation for `limit` usage.
        fn storage_kill_version_4(
            &mut self,
            storage_key: &[u8],
            maybe_limit: Option<u32>,
            maybe_cursor: Option<Vec<u8>>,
        ) -> MultiRemovalResults;
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageClearVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageClearVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'clear' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_version_1(&storage_key, &key);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageClearVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_clear_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'clear' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'clear' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'clear' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                key_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageClearPrefixVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageClearPrefixVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut prefix = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    prefix_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_prefix_version_1(&storage_key, &prefix);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageClearPrefixVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_clear_prefix_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let prefix_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'prefix': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    prefix_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                prefix_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageClearPrefixVersion2;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageClearPrefixVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut prefix = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    prefix_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_prefix_version_2(&storage_key, &prefix, limit);
            let __result__ = <KillStorageResult as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageClearPrefixVersion2 {
        fn name(&self) -> &str {
            "ext_default_child_storage_clear_prefix_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let prefix_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'prefix': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    prefix_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'limit': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                prefix_ffi_value,
                limit_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageClearPrefixVersion3;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageClearPrefixVersion3 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            maybe_limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            maybe_cursor_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut prefix = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    prefix_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut maybe_limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut maybe_cursor = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_cursor_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_cursor' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_prefix_version_3(
                &storage_key,
                &prefix,
                maybe_limit,
                maybe_cursor,
            );
            let __result__ = <MultiRemovalResults as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageClearPrefixVersion3 {
        fn name(&self) -> &str {
            "ext_default_child_storage_clear_prefix_version_3"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let prefix_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'prefix': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    prefix_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'prefix' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let maybe_limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_limit': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_limit' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let maybe_cursor_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_cursor': number of arguments given to 'clear_prefix' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_cursor_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_cursor_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_cursor' argument through the WASM FFI boundary while executing 'clear_prefix' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                prefix_ffi_value,
                maybe_limit_ffi_value,
                maybe_cursor_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageExistsVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageExistsVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'exists' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'exists' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = exists_version_1(&storage_key, &key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageExistsVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_exists_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'exists' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'exists' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'exists' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'exists' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageGetVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageGetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<Vec<u8>> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'get' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'get' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = get_version_1(&storage_key, &key);
            let __result__ = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageGetVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_get_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        Vec<u8>,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'get' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'get' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'get' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'get' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageNextKeyVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageNextKeyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<Vec<u8>> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'next_key' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'next_key' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = next_key_version_1(&storage_key, &key);
            let __result__ = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageNextKeyVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_next_key_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        Vec<u8>,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'next_key' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'next_key' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'next_key' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'next_key' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageReadVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageReadVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_out_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_offset_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<u32> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut value_out = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_out_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value_out' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut value_offset = <u32 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_offset_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value_offset' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = read_version_1(
                &storage_key,
                &key,
                &mut value_out,
                value_offset,
            );
            <[u8] as proc_macro_runtime_interface::host::IntoPreallocatedFFIValue>::into_preallocated_ffi_value(
                value_out,
                __function_context__,
                value_out_ffi_value,
            )?;
            let __result__ = <Option<
                u32,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageReadVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_read_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<u32 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        u32,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'read' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'read' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let value_out_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value_out': number of arguments given to 'read' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_out_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_out_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value_out' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let value_offset_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value_offset': number of arguments given to 'read' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_offset_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_offset_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value_offset' argument through the WASM FFI boundary while executing 'read' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                key_ffi_value,
                value_out_ffi_value,
                value_offset_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageRootVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageRootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'root' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = root_version_1(&storage_key);
            let __result__ = <Vec<
                u8,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageRootVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        u8,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'root' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'root' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, storage_key_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageRootVersion2;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageRootVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'root' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'root' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = root_version_2(&storage_key, version);
            let __result__ = <Vec<
                u8,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageRootVersion2 {
        fn name(&self) -> &str {
            "ext_default_child_storage_root_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        u8,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'root' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'root' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'root' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'root' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageSetVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageSetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'set' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'set' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'set' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = set_version_1(&storage_key, &key, &value);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageSetVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_set_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'set' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'set' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'set' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'set' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'set' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'set' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageStorageKillVersion1;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageStorageKillVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = storage_kill_version_1(&storage_key);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageStorageKillVersion1 {
        fn name(&self) -> &str {
            "ext_default_child_storage_storage_kill_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, storage_key_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageStorageKillVersion2;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageStorageKillVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = storage_kill_version_2(&storage_key, limit);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageStorageKillVersion2 {
        fn name(&self) -> &str {
            "ext_default_child_storage_storage_kill_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'limit': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                limit_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageStorageKillVersion3;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageStorageKillVersion3 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = storage_kill_version_3(&storage_key, limit);
            let __result__ = <KillStorageResult as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageStorageKillVersion3 {
        fn name(&self) -> &str {
            "ext_default_child_storage_storage_kill_version_3"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'limit': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'limit' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                limit_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtDefaultChildStorageStorageKillVersion4;
    #[cfg(feature = "std")]
    impl ExtDefaultChildStorageStorageKillVersion4 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            maybe_limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            maybe_cursor_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut storage_key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    storage_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut maybe_limit = <Option<
                u32,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_limit_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_limit' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let mut maybe_cursor = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    maybe_cursor_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'maybe_cursor' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'",
                        ),
                    );
                    res
                })?;
            let __result__ = storage_kill_version_4(
                &storage_key,
                maybe_limit,
                maybe_cursor,
            );
            let __result__ = <MultiRemovalResults as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtDefaultChildStorageStorageKillVersion4 {
        fn name(&self) -> &str {
            "ext_default_child_storage_storage_kill_version_4"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let storage_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'storage_key': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    storage_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'storage_key' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let maybe_limit_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_limit': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_limit_ffi_value: <Option<
                u32,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_limit_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_limit' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let maybe_cursor_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'maybe_cursor': number of arguments given to 'storage_kill' from interface 'DefaultChildStorage' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let maybe_cursor_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    maybe_cursor_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'maybe_cursor' argument through the WASM FFI boundary while executing 'storage_kill' from interface 'DefaultChildStorage'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                storage_key_ffi_value,
                maybe_limit_ffi_value,
                maybe_cursor_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtDefaultChildStorageClearVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageClearPrefixVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageClearPrefixVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageClearPrefixVersion3
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageExistsVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageGetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageNextKeyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageReadVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageRootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageRootVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageSetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageStorageKillVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageStorageKillVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageStorageKillVersion3
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtDefaultChildStorageStorageKillVersion4
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageClearVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageClearVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageClearPrefixVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageClearPrefixVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                prefix_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageClearPrefixVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageClearPrefixVersion2::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                prefix_ffi_value,
                                                limit_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageClearPrefixVersion3,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        prefix_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        maybe_limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        maybe_cursor_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageClearPrefixVersion3::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                prefix_ffi_value,
                                                maybe_limit_ffi_value,
                                                maybe_cursor_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageExistsVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageExistsVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageGetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageGetVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageNextKeyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageNextKeyVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageReadVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_out_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_offset_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<u32> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageReadVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                key_ffi_value,
                                                value_out_ffi_value,
                                                value_offset_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageRootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageRootVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageRootVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageRootVersion2::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageSetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageSetVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageStorageKillVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageStorageKillVersion1::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageStorageKillVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageStorageKillVersion2::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                limit_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageStorageKillVersion3,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <KillStorageResult as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageStorageKillVersion3::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                limit_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtDefaultChildStorageStorageKillVersion4,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        storage_key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        maybe_limit_ffi_value: <Option<
                            u32,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        maybe_cursor_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <MultiRemovalResults as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtDefaultChildStorageStorageKillVersion4::call(
                                                __function_context__,
                                                storage_key_ffi_value,
                                                maybe_limit_ffi_value,
                                                maybe_cursor_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface that provides trie related functionality.
pub mod trie {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// A trie root formed from the enumerated items.
    pub fn blake2_256_ordered_root(input: Vec<Vec<u8>>, version: StateVersion) -> H256 {
        blake2_256_ordered_root_version_2(input, version)
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the iterated items.
    pub fn blake2_256_root(
        input: Vec<(Vec<u8>, Vec<u8>)>,
        version: StateVersion,
    ) -> H256 {
        blake2_256_root_version_2(input, version)
    }
    #[cfg(feature = "std")]
    /// Verify trie proof
    pub fn blake2_256_verify_proof(
        root: H256,
        proof: &[Vec<u8>],
        key: &[u8],
        value: &[u8],
        version: StateVersion,
    ) -> bool {
        blake2_256_verify_proof_version_2(root, proof, key, value, version)
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the enumerated items.
    pub fn keccak_256_ordered_root(input: Vec<Vec<u8>>, version: StateVersion) -> H256 {
        keccak_256_ordered_root_version_2(input, version)
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the iterated items.
    pub fn keccak_256_root(
        input: Vec<(Vec<u8>, Vec<u8>)>,
        version: StateVersion,
    ) -> H256 {
        keccak_256_root_version_2(input, version)
    }
    #[cfg(feature = "std")]
    /// Verify trie proof
    pub fn keccak_256_verify_proof(
        root: H256,
        proof: &[Vec<u8>],
        key: &[u8],
        value: &[u8],
        version: StateVersion,
    ) -> bool {
        keccak_256_verify_proof_version_2(root, proof, key, value, version)
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the enumerated items.
    fn blake2_256_ordered_root_version_1(input: Vec<Vec<u8>>) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_ordered_root_version_1",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::blake2_256_ordered_root_version_1(
                    input,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the enumerated items.
    fn blake2_256_ordered_root_version_2(
        input: Vec<Vec<u8>>,
        version: StateVersion,
    ) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_ordered_root_version_2",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::blake2_256_ordered_root_version_2(
                    input,
                    version,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the iterated items.
    fn blake2_256_root_version_1(input: Vec<(Vec<u8>, Vec<u8>)>) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_root_version_1",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::blake2_256_root_version_1(
                    input,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the iterated items.
    fn blake2_256_root_version_2(
        input: Vec<(Vec<u8>, Vec<u8>)>,
        version: StateVersion,
    ) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_root_version_2",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::blake2_256_root_version_2(
                    input,
                    version,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify trie proof
    fn blake2_256_verify_proof_version_1(
        root: H256,
        proof: &[Vec<u8>],
        key: &[u8],
        value: &[u8],
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_verify_proof_version_1",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::blake2_256_verify_proof_version_1(
                    root,
                    proof,
                    key,
                    value,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify trie proof
    fn blake2_256_verify_proof_version_2(
        root: H256,
        proof: &[Vec<u8>],
        key: &[u8],
        value: &[u8],
        version: StateVersion,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_verify_proof_version_2",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::blake2_256_verify_proof_version_2(
                    root,
                    proof,
                    key,
                    value,
                    version,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the enumerated items.
    fn keccak_256_ordered_root_version_1(input: Vec<Vec<u8>>) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_ordered_root_version_1",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::keccak_256_ordered_root_version_1(
                    input,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the enumerated items.
    fn keccak_256_ordered_root_version_2(
        input: Vec<Vec<u8>>,
        version: StateVersion,
    ) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_ordered_root_version_2",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::keccak_256_ordered_root_version_2(
                    input,
                    version,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the iterated items.
    fn keccak_256_root_version_1(input: Vec<(Vec<u8>, Vec<u8>)>) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_root_version_1",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::keccak_256_root_version_1(
                    input,
                )
            })
    }
    #[cfg(feature = "std")]
    /// A trie root formed from the iterated items.
    fn keccak_256_root_version_2(
        input: Vec<(Vec<u8>, Vec<u8>)>,
        version: StateVersion,
    ) -> H256 {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_root_version_2",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::keccak_256_root_version_2(
                    input,
                    version,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify trie proof
    fn keccak_256_verify_proof_version_1(
        root: H256,
        proof: &[Vec<u8>],
        key: &[u8],
        value: &[u8],
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_verify_proof_version_1",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::keccak_256_verify_proof_version_1(
                    root,
                    proof,
                    key,
                    value,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify trie proof
    fn keccak_256_verify_proof_version_2(
        root: H256,
        proof: &[Vec<u8>],
        key: &[u8],
        value: &[u8],
        version: StateVersion,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_verify_proof_version_2",
                        "sp_io::trie",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(552u32),
                        ::core::option::Option::Some("sp_io::trie"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Trie>::keccak_256_verify_proof_version_2(
                    root,
                    proof,
                    key,
                    value,
                    version,
                )
            })
    }
    #[cfg(feature = "std")]
    impl Trie for &mut dyn proc_macro_runtime_interface::Externalities {
        /// A trie root formed from the enumerated items.
        fn blake2_256_ordered_root_version_1(input: Vec<Vec<u8>>) -> H256 {
            LayoutV0::<sp_core::Blake2Hasher>::ordered_trie_root(input)
        }
        /// A trie root formed from the enumerated items.
        fn blake2_256_ordered_root_version_2(
            input: Vec<Vec<u8>>,
            version: StateVersion,
        ) -> H256 {
            match version {
                StateVersion::V0 => {
                    LayoutV0::<sp_core::Blake2Hasher>::ordered_trie_root(input)
                }
                StateVersion::V1 => {
                    LayoutV1::<sp_core::Blake2Hasher>::ordered_trie_root(input)
                }
            }
        }
        /// A trie root formed from the iterated items.
        fn blake2_256_root_version_1(input: Vec<(Vec<u8>, Vec<u8>)>) -> H256 {
            LayoutV0::<sp_core::Blake2Hasher>::trie_root(input)
        }
        /// A trie root formed from the iterated items.
        fn blake2_256_root_version_2(
            input: Vec<(Vec<u8>, Vec<u8>)>,
            version: StateVersion,
        ) -> H256 {
            match version {
                StateVersion::V0 => LayoutV0::<sp_core::Blake2Hasher>::trie_root(input),
                StateVersion::V1 => LayoutV1::<sp_core::Blake2Hasher>::trie_root(input),
            }
        }
        /// Verify trie proof
        fn blake2_256_verify_proof_version_1(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
        ) -> bool {
            sp_trie::verify_trie_proof::<
                LayoutV0<sp_core::Blake2Hasher>,
                _,
                _,
                _,
            >(&root, proof, &[(key, Some(value))])
                .is_ok()
        }
        /// Verify trie proof
        fn blake2_256_verify_proof_version_2(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
            version: StateVersion,
        ) -> bool {
            match version {
                StateVersion::V0 => {
                    sp_trie::verify_trie_proof::<
                        LayoutV0<sp_core::Blake2Hasher>,
                        _,
                        _,
                        _,
                    >(&root, proof, &[(key, Some(value))])
                        .is_ok()
                }
                StateVersion::V1 => {
                    sp_trie::verify_trie_proof::<
                        LayoutV1<sp_core::Blake2Hasher>,
                        _,
                        _,
                        _,
                    >(&root, proof, &[(key, Some(value))])
                        .is_ok()
                }
            }
        }
        /// A trie root formed from the enumerated items.
        fn keccak_256_ordered_root_version_1(input: Vec<Vec<u8>>) -> H256 {
            LayoutV0::<sp_core::KeccakHasher>::ordered_trie_root(input)
        }
        /// A trie root formed from the enumerated items.
        fn keccak_256_ordered_root_version_2(
            input: Vec<Vec<u8>>,
            version: StateVersion,
        ) -> H256 {
            match version {
                StateVersion::V0 => {
                    LayoutV0::<sp_core::KeccakHasher>::ordered_trie_root(input)
                }
                StateVersion::V1 => {
                    LayoutV1::<sp_core::KeccakHasher>::ordered_trie_root(input)
                }
            }
        }
        /// A trie root formed from the iterated items.
        fn keccak_256_root_version_1(input: Vec<(Vec<u8>, Vec<u8>)>) -> H256 {
            LayoutV0::<sp_core::KeccakHasher>::trie_root(input)
        }
        /// A trie root formed from the iterated items.
        fn keccak_256_root_version_2(
            input: Vec<(Vec<u8>, Vec<u8>)>,
            version: StateVersion,
        ) -> H256 {
            match version {
                StateVersion::V0 => LayoutV0::<sp_core::KeccakHasher>::trie_root(input),
                StateVersion::V1 => LayoutV1::<sp_core::KeccakHasher>::trie_root(input),
            }
        }
        /// Verify trie proof
        fn keccak_256_verify_proof_version_1(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
        ) -> bool {
            sp_trie::verify_trie_proof::<
                LayoutV0<sp_core::KeccakHasher>,
                _,
                _,
                _,
            >(&root, proof, &[(key, Some(value))])
                .is_ok()
        }
        /// Verify trie proof
        fn keccak_256_verify_proof_version_2(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
            version: StateVersion,
        ) -> bool {
            match version {
                StateVersion::V0 => {
                    sp_trie::verify_trie_proof::<
                        LayoutV0<sp_core::KeccakHasher>,
                        _,
                        _,
                        _,
                    >(&root, proof, &[(key, Some(value))])
                        .is_ok()
                }
                StateVersion::V1 => {
                    sp_trie::verify_trie_proof::<
                        LayoutV1<sp_core::KeccakHasher>,
                        _,
                        _,
                        _,
                    >(&root, proof, &[(key, Some(value))])
                        .is_ok()
                }
            }
        }
    }
    trait Trie {
        /// A trie root formed from the enumerated items.
        fn blake2_256_ordered_root_version_1(input: Vec<Vec<u8>>) -> H256;
        /// A trie root formed from the enumerated items.
        fn blake2_256_ordered_root_version_2(
            input: Vec<Vec<u8>>,
            version: StateVersion,
        ) -> H256;
        /// A trie root formed from the iterated items.
        fn blake2_256_root_version_1(input: Vec<(Vec<u8>, Vec<u8>)>) -> H256;
        /// A trie root formed from the iterated items.
        fn blake2_256_root_version_2(
            input: Vec<(Vec<u8>, Vec<u8>)>,
            version: StateVersion,
        ) -> H256;
        /// Verify trie proof
        fn blake2_256_verify_proof_version_1(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
        ) -> bool;
        /// Verify trie proof
        fn blake2_256_verify_proof_version_2(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
            version: StateVersion,
        ) -> bool;
        /// A trie root formed from the enumerated items.
        fn keccak_256_ordered_root_version_1(input: Vec<Vec<u8>>) -> H256;
        /// A trie root formed from the enumerated items.
        fn keccak_256_ordered_root_version_2(
            input: Vec<Vec<u8>>,
            version: StateVersion,
        ) -> H256;
        /// A trie root formed from the iterated items.
        fn keccak_256_root_version_1(input: Vec<(Vec<u8>, Vec<u8>)>) -> H256;
        /// A trie root formed from the iterated items.
        fn keccak_256_root_version_2(
            input: Vec<(Vec<u8>, Vec<u8>)>,
            version: StateVersion,
        ) -> H256;
        /// Verify trie proof
        fn keccak_256_verify_proof_version_1(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
        ) -> bool;
        /// Verify trie proof
        fn keccak_256_verify_proof_version_2(
            root: H256,
            proof: &[Vec<u8>],
            key: &[u8],
            value: &[u8],
            version: StateVersion,
        ) -> bool;
    }
    #[cfg(feature = "std")]
    struct ExtTrieBlake2256OrderedRootVersion1;
    #[cfg(feature = "std")]
    impl ExtTrieBlake2256OrderedRootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_ordered_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_ordered_root_version_1(input);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieBlake2256OrderedRootVersion1 {
        fn name(&self) -> &str {
            "ext_trie_blake2_256_ordered_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'blake2_256_ordered_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_ordered_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, input_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieBlake2256OrderedRootVersion2;
    #[cfg(feature = "std")]
    impl ExtTrieBlake2256OrderedRootVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_ordered_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'blake2_256_ordered_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_ordered_root_version_2(input, version);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieBlake2256OrderedRootVersion2 {
        fn name(&self) -> &str {
            "ext_trie_blake2_256_ordered_root_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'blake2_256_ordered_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_ordered_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'blake2_256_ordered_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'blake2_256_ordered_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                input_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieBlake2256RootVersion1;
    #[cfg(feature = "std")]
    impl ExtTrieBlake2256RootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_root_version_1(input);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieBlake2256RootVersion1 {
        fn name(&self) -> &str {
            "ext_trie_blake2_256_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'blake2_256_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, input_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieBlake2256RootVersion2;
    #[cfg(feature = "std")]
    impl ExtTrieBlake2256RootVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'blake2_256_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_root_version_2(input, version);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieBlake2256RootVersion2 {
        fn name(&self) -> &str {
            "ext_trie_blake2_256_root_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'blake2_256_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'blake2_256_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'blake2_256_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'blake2_256_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                input_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieBlake2256VerifyProofVersion1;
    #[cfg(feature = "std")]
    impl ExtTrieBlake2256VerifyProofVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut root = <H256 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    root_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'root' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut proof = <[Vec<
                u8,
            >] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    proof_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_verify_proof_version_1(
                root,
                &proof,
                &key,
                &value,
            );
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieBlake2256VerifyProofVersion1 {
        fn name(&self) -> &str {
            "ext_trie_blake2_256_verify_proof_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let root_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'root': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    root_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'root' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let proof_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'proof': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    proof_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                root_ffi_value,
                proof_ffi_value,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieBlake2256VerifyProofVersion2;
    #[cfg(feature = "std")]
    impl ExtTrieBlake2256VerifyProofVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut root = <H256 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    root_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'root' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut proof = <[Vec<
                u8,
            >] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    proof_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_verify_proof_version_2(
                root,
                &proof,
                &key,
                &value,
                version,
            );
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieBlake2256VerifyProofVersion2 {
        fn name(&self) -> &str {
            "ext_trie_blake2_256_verify_proof_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let root_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'root': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    root_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'root' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let proof_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'proof': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    proof_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'blake2_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'blake2_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                root_ffi_value,
                proof_ffi_value,
                key_ffi_value,
                value_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieKeccak256OrderedRootVersion1;
    #[cfg(feature = "std")]
    impl ExtTrieKeccak256OrderedRootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_ordered_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_ordered_root_version_1(input);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieKeccak256OrderedRootVersion1 {
        fn name(&self) -> &str {
            "ext_trie_keccak_256_ordered_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'keccak_256_ordered_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_ordered_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, input_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieKeccak256OrderedRootVersion2;
    #[cfg(feature = "std")]
    impl ExtTrieKeccak256OrderedRootVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_ordered_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'keccak_256_ordered_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_ordered_root_version_2(input, version);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieKeccak256OrderedRootVersion2 {
        fn name(&self) -> &str {
            "ext_trie_keccak_256_ordered_root_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'keccak_256_ordered_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_ordered_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'keccak_256_ordered_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'keccak_256_ordered_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                input_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieKeccak256RootVersion1;
    #[cfg(feature = "std")]
    impl ExtTrieKeccak256RootVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_root_version_1(input);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieKeccak256RootVersion1 {
        fn name(&self) -> &str {
            "ext_trie_keccak_256_root_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'keccak_256_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, input_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieKeccak256RootVersion2;
    #[cfg(feature = "std")]
    impl ExtTrieKeccak256RootVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut input = <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    input_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'keccak_256_root' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_root_version_2(input, version);
            let __result__ = <H256 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieKeccak256RootVersion2 {
        fn name(&self) -> &str {
            "ext_trie_keccak_256_root_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let input_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'input': number of arguments given to 'keccak_256_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let input_ffi_value: <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    input_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'input' argument through the WASM FFI boundary while executing 'keccak_256_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'keccak_256_root' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'keccak_256_root' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                input_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieKeccak256VerifyProofVersion1;
    #[cfg(feature = "std")]
    impl ExtTrieKeccak256VerifyProofVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut root = <H256 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    root_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'root' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut proof = <[Vec<
                u8,
            >] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    proof_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_verify_proof_version_1(
                root,
                &proof,
                &key,
                &value,
            );
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieKeccak256VerifyProofVersion1 {
        fn name(&self) -> &str {
            "ext_trie_keccak_256_verify_proof_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let root_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'root': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    root_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'root' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let proof_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'proof': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    proof_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                root_ffi_value,
                proof_ffi_value,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTrieKeccak256VerifyProofVersion2;
    #[cfg(feature = "std")]
    impl ExtTrieKeccak256VerifyProofVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
            proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut root = <H256 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    root_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'root' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut proof = <[Vec<
                u8,
            >] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    proof_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let mut version = <StateVersion as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    version_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'version' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_verify_proof_version_2(
                root,
                &proof,
                &key,
                &value,
                version,
            );
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTrieKeccak256VerifyProofVersion2 {
        fn name(&self) -> &str {
            "ext_trie_keccak_256_verify_proof_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<H256 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<StateVersion as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let root_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'root': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    root_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'root' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let proof_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'proof': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let proof_ffi_value: <[Vec<
                u8,
            >] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    proof_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'proof' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let version_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'version': number of arguments given to 'keccak_256_verify_proof' from interface 'Trie' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    version_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'version' argument through the WASM FFI boundary while executing 'keccak_256_verify_proof' from interface 'Trie'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                root_ffi_value,
                proof_ffi_value,
                key_ffi_value,
                value_ffi_value,
                version_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtTrieBlake2256OrderedRootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieBlake2256OrderedRootVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieBlake2256RootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieBlake2256RootVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieBlake2256VerifyProofVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieBlake2256VerifyProofVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieKeccak256OrderedRootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieKeccak256OrderedRootVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieKeccak256RootVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieKeccak256RootVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieKeccak256VerifyProofVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTrieKeccak256VerifyProofVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieBlake2256OrderedRootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieBlake2256OrderedRootVersion1::call(
                                                __function_context__,
                                                input_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieBlake2256OrderedRootVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieBlake2256OrderedRootVersion2::call(
                                                __function_context__,
                                                input_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieBlake2256RootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieBlake2256RootVersion1::call(
                                                __function_context__,
                                                input_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieBlake2256RootVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieBlake2256RootVersion2::call(
                                                __function_context__,
                                                input_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieBlake2256VerifyProofVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proof_ffi_value: <[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieBlake2256VerifyProofVersion1::call(
                                                __function_context__,
                                                root_ffi_value,
                                                proof_ffi_value,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieBlake2256VerifyProofVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proof_ffi_value: <[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieBlake2256VerifyProofVersion2::call(
                                                __function_context__,
                                                root_ffi_value,
                                                proof_ffi_value,
                                                key_ffi_value,
                                                value_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieKeccak256OrderedRootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieKeccak256OrderedRootVersion1::call(
                                                __function_context__,
                                                input_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieKeccak256OrderedRootVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieKeccak256OrderedRootVersion2::call(
                                                __function_context__,
                                                input_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieKeccak256RootVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieKeccak256RootVersion1::call(
                                                __function_context__,
                                                input_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieKeccak256RootVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        input_ffi_value: <Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieKeccak256RootVersion2::call(
                                                __function_context__,
                                                input_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieKeccak256VerifyProofVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proof_ffi_value: <[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieKeccak256VerifyProofVersion1::call(
                                                __function_context__,
                                                root_ffi_value,
                                                proof_ffi_value,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTrieKeccak256VerifyProofVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        root_ffi_value: <H256 as proc_macro_runtime_interface::RIType>::FFIType,
                        proof_ffi_value: <[Vec<
                            u8,
                        >] as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        version_ffi_value: <StateVersion as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTrieKeccak256VerifyProofVersion2::call(
                                                __function_context__,
                                                root_ffi_value,
                                                proof_ffi_value,
                                                key_ffi_value,
                                                value_ffi_value,
                                                version_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface that provides miscellaneous functions for communicating between the runtime and the
/// node.
pub mod misc {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Print any `u8` slice as hex.
    pub fn print_hex(data: &[u8]) {
        print_hex_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Print a number.
    pub fn print_num(val: u64) {
        print_num_version_1(val)
    }
    #[cfg(feature = "std")]
    /// Print any valid `utf8` buffer.
    pub fn print_utf8(utf8: &[u8]) {
        print_utf8_version_1(utf8)
    }
    #[cfg(feature = "std")]
    /// Extract the runtime version of the given wasm blob by calling `Core_version`.
    ///
    /// Returns `None` if calling the function failed for any reason or `Some(Vec<u8>)` where
    /// the `Vec<u8>` holds the SCALE encoded runtime version.
    ///
    /// # Performance
    ///
    /// This function may be very expensive to call depending on the wasm binary. It may be
    /// relatively cheap if the wasm binary contains version information. In that case,
    /// uncompression of the wasm blob is the dominating factor.
    ///
    /// If the wasm binary does not have the version information attached, then a legacy mechanism
    /// may be involved. This means that a runtime call will be performed to query the version.
    ///
    /// Calling into the runtime may be incredible expensive and should be approached with care.
    pub fn runtime_version(wasm: &[u8]) -> Option<Vec<u8>> {
        runtime_version_version_1(wasm)
    }
    #[cfg(feature = "std")]
    /// Print any `u8` slice as hex.
    fn print_hex_version_1(data: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "print_hex_version_1",
                        "sp_io::misc",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(687u32),
                        ::core::option::Option::Some("sp_io::misc"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Misc>::print_hex_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Print a number.
    fn print_num_version_1(val: u64) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "print_num_version_1",
                        "sp_io::misc",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(687u32),
                        ::core::option::Option::Some("sp_io::misc"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Misc>::print_num_version_1(
                    val,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Print any valid `utf8` buffer.
    fn print_utf8_version_1(utf8: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "print_utf8_version_1",
                        "sp_io::misc",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(687u32),
                        ::core::option::Option::Some("sp_io::misc"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Misc>::print_utf8_version_1(
                    utf8,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Extract the runtime version of the given wasm blob by calling `Core_version`.
    ///
    /// Returns `None` if calling the function failed for any reason or `Some(Vec<u8>)` where
    /// the `Vec<u8>` holds the SCALE encoded runtime version.
    ///
    /// # Performance
    ///
    /// This function may be very expensive to call depending on the wasm binary. It may be
    /// relatively cheap if the wasm binary contains version information. In that case,
    /// uncompression of the wasm blob is the dominating factor.
    ///
    /// If the wasm binary does not have the version information attached, then a legacy mechanism
    /// may be involved. This means that a runtime call will be performed to query the version.
    ///
    /// Calling into the runtime may be incredible expensive and should be approached with care.
    fn runtime_version_version_1(wasm: &[u8]) -> Option<Vec<u8>> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "runtime_version_version_1",
                        "sp_io::misc",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(687u32),
                        ::core::option::Option::Some("sp_io::misc"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Misc::runtime_version_version_1(
                        &mut __externalities__,
                        wasm,
                    ))
                    .expect(
                        "`runtime_version_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl Misc for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Print any `u8` slice as hex.
        fn print_hex_version_1(data: &[u8]) {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("{0}", HexDisplay::from(&data)),
                        lvl,
                        &(
                            "runtime",
                            "sp_io::misc",
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        706u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
        }
        /// Print a number.
        fn print_num_version_1(val: u64) {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("{0}", val),
                        lvl,
                        &(
                            "runtime",
                            "sp_io::misc",
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        694u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
        }
        /// Print any valid `utf8` buffer.
        fn print_utf8_version_1(utf8: &[u8]) {
            if let Ok(data) = std::str::from_utf8(utf8) {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("{0}", data),
                            lvl,
                            &(
                                "runtime",
                                "sp_io::misc",
                                "substrate/primitives/io/src/lib.rs",
                            ),
                            700u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
            }
        }
        /// Extract the runtime version of the given wasm blob by calling `Core_version`.
        ///
        /// Returns `None` if calling the function failed for any reason or `Some(Vec<u8>)` where
        /// the `Vec<u8>` holds the SCALE encoded runtime version.
        ///
        /// # Performance
        ///
        /// This function may be very expensive to call depending on the wasm binary. It may be
        /// relatively cheap if the wasm binary contains version information. In that case,
        /// uncompression of the wasm blob is the dominating factor.
        ///
        /// If the wasm binary does not have the version information attached, then a legacy mechanism
        /// may be involved. This means that a runtime call will be performed to query the version.
        ///
        /// Calling into the runtime may be incredible expensive and should be approached with care.
        fn runtime_version_version_1(&mut self, wasm: &[u8]) -> Option<Vec<u8>> {
            use sp_core::traits::ReadRuntimeVersionExt;
            let mut ext = sp_state_machine::BasicExternalities::default();
            match self
                .extension::<ReadRuntimeVersionExt>()
                .expect("No `ReadRuntimeVersionExt` associated for the current context!")
                .read_runtime_version(wasm, &mut ext)
            {
                Ok(v) => Some(v),
                Err(err) => {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "cannot read version from the given runtime: {0}",
                                    err,
                                ),
                                lvl,
                                &(
                                    LOG_TARGET,
                                    "sp_io::misc",
                                    "substrate/primitives/io/src/lib.rs",
                                ),
                                736u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    None
                }
            }
        }
    }
    trait Misc {
        /// Print any `u8` slice as hex.
        fn print_hex_version_1(data: &[u8]);
        /// Print a number.
        fn print_num_version_1(val: u64);
        /// Print any valid `utf8` buffer.
        fn print_utf8_version_1(utf8: &[u8]);
        /// Extract the runtime version of the given wasm blob by calling `Core_version`.
        ///
        /// Returns `None` if calling the function failed for any reason or `Some(Vec<u8>)` where
        /// the `Vec<u8>` holds the SCALE encoded runtime version.
        ///
        /// # Performance
        ///
        /// This function may be very expensive to call depending on the wasm binary. It may be
        /// relatively cheap if the wasm binary contains version information. In that case,
        /// uncompression of the wasm blob is the dominating factor.
        ///
        /// If the wasm binary does not have the version information attached, then a legacy mechanism
        /// may be involved. This means that a runtime call will be performed to query the version.
        ///
        /// Calling into the runtime may be incredible expensive and should be approached with care.
        fn runtime_version_version_1(&mut self, wasm: &[u8]) -> Option<Vec<u8>>;
    }
    #[cfg(feature = "std")]
    struct ExtMiscPrintHexVersion1;
    #[cfg(feature = "std")]
    impl ExtMiscPrintHexVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'print_hex' from interface 'Misc'",
                        ),
                    );
                    res
                })?;
            let __result__ = print_hex_version_1(&data);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtMiscPrintHexVersion1 {
        fn name(&self) -> &str {
            "ext_misc_print_hex_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'print_hex' from interface 'Misc' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'print_hex' from interface 'Misc'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtMiscPrintNumVersion1;
    #[cfg(feature = "std")]
    impl ExtMiscPrintNumVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            val_ffi_value: <u64 as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut val = <u64 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    val_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'val' argument through the WASM FFI boundary while executing 'print_num' from interface 'Misc'",
                        ),
                    );
                    res
                })?;
            let __result__ = print_num_version_1(val);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtMiscPrintNumVersion1 {
        fn name(&self) -> &str {
            "ext_misc_print_num_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<u64 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let val_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'val': number of arguments given to 'print_num' from interface 'Misc' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let val_ffi_value: <u64 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    val_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'val' argument through the WASM FFI boundary while executing 'print_num' from interface 'Misc'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, val_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtMiscPrintUtf8Version1;
    #[cfg(feature = "std")]
    impl ExtMiscPrintUtf8Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            utf8_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut utf8 = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    utf8_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'utf8' argument through the WASM FFI boundary while executing 'print_utf8' from interface 'Misc'",
                        ),
                    );
                    res
                })?;
            let __result__ = print_utf8_version_1(&utf8);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtMiscPrintUtf8Version1 {
        fn name(&self) -> &str {
            "ext_misc_print_utf8_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let utf8_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'utf8': number of arguments given to 'print_utf8' from interface 'Misc' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let utf8_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    utf8_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'utf8' argument through the WASM FFI boundary while executing 'print_utf8' from interface 'Misc'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, utf8_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtMiscRuntimeVersionVersion1;
    #[cfg(feature = "std")]
    impl ExtMiscRuntimeVersionVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            wasm_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<Vec<u8>> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut wasm = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    wasm_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'wasm' argument through the WASM FFI boundary while executing 'runtime_version' from interface 'Misc'",
                        ),
                    );
                    res
                })?;
            let __result__ = runtime_version_version_1(&wasm);
            let __result__ = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtMiscRuntimeVersionVersion1 {
        fn name(&self) -> &str {
            "ext_misc_runtime_version_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        Vec<u8>,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let wasm_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'wasm': number of arguments given to 'runtime_version' from interface 'Misc' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let wasm_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    wasm_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'wasm' argument through the WASM FFI boundary while executing 'runtime_version' from interface 'Misc'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, wasm_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtMiscPrintHexVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtMiscPrintNumVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtMiscPrintUtf8Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtMiscRuntimeVersionVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtMiscPrintHexVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtMiscPrintHexVersion1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtMiscPrintNumVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        val_ffi_value: <u64 as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtMiscPrintNumVersion1::call(
                                                __function_context__,
                                                val_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtMiscPrintUtf8Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        utf8_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtMiscPrintUtf8Version1::call(
                                                __function_context__,
                                                utf8_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtMiscRuntimeVersionVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        wasm_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtMiscRuntimeVersionVersion1::call(
                                                __function_context__,
                                                wasm_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Extension to signal to [`crypt::ed25519_verify`] to use the dalek crate.
///
/// The switch from `ed25519-dalek` to `ed25519-zebra` was a breaking change.
/// `ed25519-zebra` is more permissive when it comes to the verification of signatures.
/// This means that some chains may fail to sync from genesis when using `ed25519-zebra`.
/// So, this extension can be registered to the runtime execution environment to signal
/// that `ed25519-dalek` should be used for verification. The extension can be registered
/// in the following way:
///
/// ```nocompile
/// client.execution_extensions().set_extensions_factory(
/// 	// Let the `UseDalekExt` extension being registered for each runtime invocation
/// 	// until the execution happens in the context of block `1000`.
/// 	sc_client_api::execution_extensions::ExtensionBeforeBlock::<Block, UseDalekExt>::new(1000)
/// );
/// ```
pub struct UseDalekExt;
impl ::sp_externalities::Extension for UseDalekExt {
    fn as_mut_any(&mut self) -> &mut dyn std::any::Any {
        self
    }
    fn type_id(&self) -> std::any::TypeId {
        std::any::Any::type_id(self)
    }
}
#[cfg(feature = "std")]
impl Default for UseDalekExt {
    fn default() -> Self {
        Self
    }
}
/// Interfaces for working with crypto related types from within the runtime.
pub mod crypto {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Generate an `ecdsa` key for the given key type using an optional `seed` and
    /// store it in the keystore.
    ///
    /// The `seed` needs to be a valid utf8.
    ///
    /// Returns the public key.
    pub fn ecdsa_generate(id: KeyTypeId, seed: Option<Vec<u8>>) -> ecdsa::Public {
        ecdsa_generate_version_1(id, seed)
    }
    #[cfg(feature = "std")]
    /// Returns all `ecdsa` public keys for the given key id from the keystore.
    pub fn ecdsa_public_keys(id: KeyTypeId) -> Vec<ecdsa::Public> {
        ecdsa_public_keys_version_1(id)
    }
    #[cfg(feature = "std")]
    /// Sign the given `msg` with the `ecdsa` key that corresponds to the given public key and
    /// key type in the keystore.
    ///
    /// Returns the signature.
    pub fn ecdsa_sign(
        id: KeyTypeId,
        pub_key: &ecdsa::Public,
        msg: &[u8],
    ) -> Option<ecdsa::Signature> {
        ecdsa_sign_version_1(id, pub_key, msg)
    }
    #[cfg(feature = "std")]
    /// Sign the given a pre-hashed `msg` with the `ecdsa` key that corresponds to the given public
    /// key and key type in the keystore.
    ///
    /// Returns the signature.
    pub fn ecdsa_sign_prehashed(
        id: KeyTypeId,
        pub_key: &ecdsa::Public,
        msg: &[u8; 32],
    ) -> Option<ecdsa::Signature> {
        ecdsa_sign_prehashed_version_1(id, pub_key, msg)
    }
    #[cfg(feature = "std")]
    /// Verify `ecdsa` signature.
    ///
    /// Returns `true` when the verification was successful.
    pub fn ecdsa_verify(
        sig: &ecdsa::Signature,
        msg: &[u8],
        pub_key: &ecdsa::Public,
    ) -> bool {
        ecdsa_verify_version_2(sig, msg, pub_key)
    }
    #[cfg(feature = "std")]
    /// Verify `ecdsa` signature with pre-hashed `msg`.
    ///
    /// Returns `true` when the verification was successful.
    pub fn ecdsa_verify_prehashed(
        sig: &ecdsa::Signature,
        msg: &[u8; 32],
        pub_key: &ecdsa::Public,
    ) -> bool {
        ecdsa_verify_prehashed_version_1(sig, msg, pub_key)
    }
    #[cfg(feature = "std")]
    /// Generate an `ed22519` key for the given key type using an optional `seed` and
    /// store it in the keystore.
    ///
    /// The `seed` needs to be a valid utf8.
    ///
    /// Returns the public key.
    pub fn ed25519_generate(id: KeyTypeId, seed: Option<Vec<u8>>) -> ed25519::Public {
        ed25519_generate_version_1(id, seed)
    }
    #[cfg(feature = "std")]
    /// Returns all `ed25519` public keys for the given key id from the keystore.
    pub fn ed25519_public_keys(id: KeyTypeId) -> Vec<ed25519::Public> {
        ed25519_public_keys_version_1(id)
    }
    #[cfg(feature = "std")]
    /// Sign the given `msg` with the `ed25519` key that corresponds to the given public key and
    /// key type in the keystore.
    ///
    /// Returns the signature.
    pub fn ed25519_sign(
        id: KeyTypeId,
        pub_key: &ed25519::Public,
        msg: &[u8],
    ) -> Option<ed25519::Signature> {
        ed25519_sign_version_1(id, pub_key, msg)
    }
    #[cfg(feature = "std")]
    /// Verify `ed25519` signature.
    ///
    /// Returns `true` when the verification was successful.
    pub fn ed25519_verify(
        sig: &ed25519::Signature,
        msg: &[u8],
        pub_key: &ed25519::Public,
    ) -> bool {
        ed25519_verify_version_1(sig, msg, pub_key)
    }
    #[cfg(feature = "std")]
    /// Verify and recover a SECP256k1 ECDSA signature.
    ///
    /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
    /// - `msg` is the blake2-256 hash of the message.
    ///
    /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
    /// (doesn't include the 0x04 prefix).
    pub fn secp256k1_ecdsa_recover(
        sig: &[u8; 65],
        msg: &[u8; 32],
    ) -> Result<[u8; 64], EcdsaVerifyError> {
        secp256k1_ecdsa_recover_version_2(sig, msg)
    }
    #[cfg(feature = "std")]
    /// Verify and recover a SECP256k1 ECDSA signature.
    ///
    /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
    /// - `msg` is the blake2-256 hash of the message.
    ///
    /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
    pub fn secp256k1_ecdsa_recover_compressed(
        sig: &[u8; 65],
        msg: &[u8; 32],
    ) -> Result<[u8; 33], EcdsaVerifyError> {
        secp256k1_ecdsa_recover_compressed_version_2(sig, msg)
    }
    #[cfg(feature = "std")]
    /// Generate an `sr22519` key for the given key type using an optional seed and
    /// store it in the keystore.
    ///
    /// The `seed` needs to be a valid utf8.
    ///
    /// Returns the public key.
    pub fn sr25519_generate(id: KeyTypeId, seed: Option<Vec<u8>>) -> sr25519::Public {
        sr25519_generate_version_1(id, seed)
    }
    #[cfg(feature = "std")]
    /// Returns all `sr25519` public keys for the given key id from the keystore.
    pub fn sr25519_public_keys(id: KeyTypeId) -> Vec<sr25519::Public> {
        sr25519_public_keys_version_1(id)
    }
    #[cfg(feature = "std")]
    /// Sign the given `msg` with the `sr25519` key that corresponds to the given public key and
    /// key type in the keystore.
    ///
    /// Returns the signature.
    pub fn sr25519_sign(
        id: KeyTypeId,
        pub_key: &sr25519::Public,
        msg: &[u8],
    ) -> Option<sr25519::Signature> {
        sr25519_sign_version_1(id, pub_key, msg)
    }
    #[cfg(feature = "std")]
    /// Verify `sr25519` signature.
    ///
    /// Returns `true` when the verification was successful.
    pub fn sr25519_verify(
        sig: &sr25519::Signature,
        msg: &[u8],
        pub_key: &sr25519::Public,
    ) -> bool {
        sr25519_verify_version_2(sig, msg, pub_key)
    }
    #[cfg(feature = "std")]
    /// Register a `ecdsa` signature for batch verification.
    ///
    /// Batch verification must be enabled by calling [`start_batch_verify`].
    /// If batch verification is not enabled, the signature will be verified immediatley.
    /// To get the result of the batch verification, [`finish_batch_verify`]
    /// needs to be called.
    ///
    /// Returns `true` when the verification is either successful or batched.
    ///
    /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
    /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
    /// The implementation emulates the old behavior, but isn't doing any batch verification
    /// anymore.
    fn ecdsa_batch_verify_version_1(
        sig: &ecdsa::Signature,
        msg: &[u8],
        pub_key: &ecdsa::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_batch_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ecdsa_batch_verify_version_1(
                        &mut __externalities__,
                        sig,
                        msg,
                        pub_key,
                    ))
                    .expect(
                        "`ecdsa_batch_verify_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Generate an `ecdsa` key for the given key type using an optional `seed` and
    /// store it in the keystore.
    ///
    /// The `seed` needs to be a valid utf8.
    ///
    /// Returns the public key.
    fn ecdsa_generate_version_1(id: KeyTypeId, seed: Option<Vec<u8>>) -> ecdsa::Public {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_generate_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ecdsa_generate_version_1(
                        &mut __externalities__,
                        id,
                        seed,
                    ))
                    .expect(
                        "`ecdsa_generate_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns all `ecdsa` public keys for the given key id from the keystore.
    fn ecdsa_public_keys_version_1(id: KeyTypeId) -> Vec<ecdsa::Public> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_public_keys_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ecdsa_public_keys_version_1(
                        &mut __externalities__,
                        id,
                    ))
                    .expect(
                        "`ecdsa_public_keys_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Sign the given `msg` with the `ecdsa` key that corresponds to the given public key and
    /// key type in the keystore.
    ///
    /// Returns the signature.
    fn ecdsa_sign_version_1(
        id: KeyTypeId,
        pub_key: &ecdsa::Public,
        msg: &[u8],
    ) -> Option<ecdsa::Signature> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_sign_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ecdsa_sign_version_1(
                        &mut __externalities__,
                        id,
                        pub_key,
                        msg,
                    ))
                    .expect(
                        "`ecdsa_sign_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Sign the given a pre-hashed `msg` with the `ecdsa` key that corresponds to the given public
    /// key and key type in the keystore.
    ///
    /// Returns the signature.
    fn ecdsa_sign_prehashed_version_1(
        id: KeyTypeId,
        pub_key: &ecdsa::Public,
        msg: &[u8; 32],
    ) -> Option<ecdsa::Signature> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_sign_prehashed_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ecdsa_sign_prehashed_version_1(
                        &mut __externalities__,
                        id,
                        pub_key,
                        msg,
                    ))
                    .expect(
                        "`ecdsa_sign_prehashed_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Verify `ecdsa` signature.
    ///
    /// Returns `true` when the verification was successful.
    /// This version is able to handle, non-standard, overflowing signatures.
    fn ecdsa_verify_version_1(
        sig: &ecdsa::Signature,
        msg: &[u8],
        pub_key: &ecdsa::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::ecdsa_verify_version_1(
                    sig,
                    msg,
                    pub_key,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify `ecdsa` signature.
    ///
    /// Returns `true` when the verification was successful.
    fn ecdsa_verify_version_2(
        sig: &ecdsa::Signature,
        msg: &[u8],
        pub_key: &ecdsa::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_verify_version_2",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::ecdsa_verify_version_2(
                    sig,
                    msg,
                    pub_key,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify `ecdsa` signature with pre-hashed `msg`.
    ///
    /// Returns `true` when the verification was successful.
    fn ecdsa_verify_prehashed_version_1(
        sig: &ecdsa::Signature,
        msg: &[u8; 32],
        pub_key: &ecdsa::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ecdsa_verify_prehashed_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::ecdsa_verify_prehashed_version_1(
                    sig,
                    msg,
                    pub_key,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Register a `ed25519` signature for batch verification.
    ///
    /// Batch verification must be enabled by calling [`start_batch_verify`].
    /// If batch verification is not enabled, the signature will be verified immediately.
    /// To get the result of the batch verification, [`finish_batch_verify`]
    /// needs to be called.
    ///
    /// Returns `true` when the verification is either successful or batched.
    ///
    /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
    /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
    /// The implementation emulates the old behavior, but isn't doing any batch verification
    /// anymore.
    fn ed25519_batch_verify_version_1(
        sig: &ed25519::Signature,
        msg: &[u8],
        pub_key: &ed25519::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ed25519_batch_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ed25519_batch_verify_version_1(
                        &mut __externalities__,
                        sig,
                        msg,
                        pub_key,
                    ))
                    .expect(
                        "`ed25519_batch_verify_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Generate an `ed22519` key for the given key type using an optional `seed` and
    /// store it in the keystore.
    ///
    /// The `seed` needs to be a valid utf8.
    ///
    /// Returns the public key.
    fn ed25519_generate_version_1(
        id: KeyTypeId,
        seed: Option<Vec<u8>>,
    ) -> ed25519::Public {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ed25519_generate_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ed25519_generate_version_1(
                        &mut __externalities__,
                        id,
                        seed,
                    ))
                    .expect(
                        "`ed25519_generate_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns all `ed25519` public keys for the given key id from the keystore.
    fn ed25519_public_keys_version_1(id: KeyTypeId) -> Vec<ed25519::Public> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ed25519_public_keys_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ed25519_public_keys_version_1(
                        &mut __externalities__,
                        id,
                    ))
                    .expect(
                        "`ed25519_public_keys_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Sign the given `msg` with the `ed25519` key that corresponds to the given public key and
    /// key type in the keystore.
    ///
    /// Returns the signature.
    fn ed25519_sign_version_1(
        id: KeyTypeId,
        pub_key: &ed25519::Public,
        msg: &[u8],
    ) -> Option<ed25519::Signature> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ed25519_sign_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::ed25519_sign_version_1(
                        &mut __externalities__,
                        id,
                        pub_key,
                        msg,
                    ))
                    .expect(
                        "`ed25519_sign_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Verify `ed25519` signature.
    ///
    /// Returns `true` when the verification was successful.
    fn ed25519_verify_version_1(
        sig: &ed25519::Signature,
        msg: &[u8],
        pub_key: &ed25519::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "ed25519_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::ed25519_verify_version_1(
                    sig,
                    msg,
                    pub_key,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Finish batch-verification of signatures.
    ///
    /// Verify or wait for verification to finish for all signatures which were previously
    /// deferred by `sr25519_verify`/`ed25519_verify`.
    ///
    /// Will panic if no `VerificationExt` is registered (`start_batch_verify` was not called).
    ///
    /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
    /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
    /// The implementation emulates the old behavior, but isn't doing any batch verification
    /// anymore.
    fn finish_batch_verify_version_1() -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "finish_batch_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::finish_batch_verify_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`finish_batch_verify_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Verify and recover a SECP256k1 ECDSA signature.
    ///
    /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
    /// - `msg` is the blake2-256 hash of the message.
    ///
    /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
    /// (doesn't include the 0x04 prefix).
    /// This version is able to handle, non-standard, overflowing signatures.
    fn secp256k1_ecdsa_recover_version_1(
        sig: &[u8; 65],
        msg: &[u8; 32],
    ) -> Result<[u8; 64], EcdsaVerifyError> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "secp256k1_ecdsa_recover_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::secp256k1_ecdsa_recover_version_1(
                    sig,
                    msg,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify and recover a SECP256k1 ECDSA signature.
    ///
    /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
    /// - `msg` is the blake2-256 hash of the message.
    ///
    /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
    /// (doesn't include the 0x04 prefix).
    fn secp256k1_ecdsa_recover_version_2(
        sig: &[u8; 65],
        msg: &[u8; 32],
    ) -> Result<[u8; 64], EcdsaVerifyError> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "secp256k1_ecdsa_recover_version_2",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::secp256k1_ecdsa_recover_version_2(
                    sig,
                    msg,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify and recover a SECP256k1 ECDSA signature.
    ///
    /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
    /// - `msg` is the blake2-256 hash of the message.
    ///
    /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
    fn secp256k1_ecdsa_recover_compressed_version_1(
        sig: &[u8; 65],
        msg: &[u8; 32],
    ) -> Result<[u8; 33], EcdsaVerifyError> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "secp256k1_ecdsa_recover_compressed_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::secp256k1_ecdsa_recover_compressed_version_1(
                    sig,
                    msg,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify and recover a SECP256k1 ECDSA signature.
    ///
    /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
    /// - `msg` is the blake2-256 hash of the message.
    ///
    /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
    fn secp256k1_ecdsa_recover_compressed_version_2(
        sig: &[u8; 65],
        msg: &[u8; 32],
    ) -> Result<[u8; 33], EcdsaVerifyError> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "secp256k1_ecdsa_recover_compressed_version_2",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::secp256k1_ecdsa_recover_compressed_version_2(
                    sig,
                    msg,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Register a `sr25519` signature for batch verification.
    ///
    /// Batch verification must be enabled by calling [`start_batch_verify`].
    /// If batch verification is not enabled, the signature will be verified immediately.
    /// To get the result of the batch verification, [`finish_batch_verify`]
    /// needs to be called.
    ///
    /// Returns `true` when the verification is either successful or batched.
    ///
    /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
    /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
    /// The implementation emulates the old behavior, but isn't doing any batch verification
    /// anymore.
    fn sr25519_batch_verify_version_1(
        sig: &sr25519::Signature,
        msg: &[u8],
        pub_key: &sr25519::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sr25519_batch_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::sr25519_batch_verify_version_1(
                        &mut __externalities__,
                        sig,
                        msg,
                        pub_key,
                    ))
                    .expect(
                        "`sr25519_batch_verify_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Generate an `sr22519` key for the given key type using an optional seed and
    /// store it in the keystore.
    ///
    /// The `seed` needs to be a valid utf8.
    ///
    /// Returns the public key.
    fn sr25519_generate_version_1(
        id: KeyTypeId,
        seed: Option<Vec<u8>>,
    ) -> sr25519::Public {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sr25519_generate_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::sr25519_generate_version_1(
                        &mut __externalities__,
                        id,
                        seed,
                    ))
                    .expect(
                        "`sr25519_generate_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns all `sr25519` public keys for the given key id from the keystore.
    fn sr25519_public_keys_version_1(id: KeyTypeId) -> Vec<sr25519::Public> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sr25519_public_keys_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::sr25519_public_keys_version_1(
                        &mut __externalities__,
                        id,
                    ))
                    .expect(
                        "`sr25519_public_keys_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Sign the given `msg` with the `sr25519` key that corresponds to the given public key and
    /// key type in the keystore.
    ///
    /// Returns the signature.
    fn sr25519_sign_version_1(
        id: KeyTypeId,
        pub_key: &sr25519::Public,
        msg: &[u8],
    ) -> Option<sr25519::Signature> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sr25519_sign_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::sr25519_sign_version_1(
                        &mut __externalities__,
                        id,
                        pub_key,
                        msg,
                    ))
                    .expect(
                        "`sr25519_sign_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Verify an `sr25519` signature.
    ///
    /// Returns `true` when the verification in successful regardless of
    /// signature version.
    fn sr25519_verify_version_1(
        sig: &sr25519::Signature,
        msg: &[u8],
        pubkey: &sr25519::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sr25519_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::sr25519_verify_version_1(
                    sig,
                    msg,
                    pubkey,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Verify `sr25519` signature.
    ///
    /// Returns `true` when the verification was successful.
    fn sr25519_verify_version_2(
        sig: &sr25519::Signature,
        msg: &[u8],
        pub_key: &sr25519::Public,
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sr25519_verify_version_2",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Crypto>::sr25519_verify_version_2(
                    sig,
                    msg,
                    pub_key,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Start verification extension.
    ///
    /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
    /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
    /// The implementation emulates the old behavior, but isn't doing any batch verification
    /// anymore.
    fn start_batch_verify_version_1() {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "start_batch_verify_version_1",
                        "sp_io::crypto",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(776u32),
                        ::core::option::Option::Some("sp_io::crypto"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Crypto::start_batch_verify_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`start_batch_verify_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl Crypto for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Register a `ecdsa` signature for batch verification.
        ///
        /// Batch verification must be enabled by calling [`start_batch_verify`].
        /// If batch verification is not enabled, the signature will be verified immediatley.
        /// To get the result of the batch verification, [`finish_batch_verify`]
        /// needs to be called.
        ///
        /// Returns `true` when the verification is either successful or batched.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn ecdsa_batch_verify_version_1(
            &mut self,
            sig: &ecdsa::Signature,
            msg: &[u8],
            pub_key: &ecdsa::Public,
        ) -> bool {
            let res = ecdsa_verify(sig, msg, pub_key);
            if let Some(ext) = self.extension::<VerificationExtDeprecated>() {
                ext.0 &= res;
            }
            res
        }
        /// Generate an `ecdsa` key for the given key type using an optional `seed` and
        /// store it in the keystore.
        ///
        /// The `seed` needs to be a valid utf8.
        ///
        /// Returns the public key.
        fn ecdsa_generate_version_1(
            &mut self,
            id: KeyTypeId,
            seed: Option<Vec<u8>>,
        ) -> ecdsa::Public {
            let seed = seed
                .as_ref()
                .map(|s| std::str::from_utf8(s).expect("Seed is valid utf8!"));
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ecdsa_generate_new(id, seed)
                .expect("`ecdsa_generate` failed")
        }
        /// Returns all `ecdsa` public keys for the given key id from the keystore.
        fn ecdsa_public_keys_version_1(&mut self, id: KeyTypeId) -> Vec<ecdsa::Public> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ecdsa_public_keys(id)
        }
        /// Sign the given `msg` with the `ecdsa` key that corresponds to the given public key and
        /// key type in the keystore.
        ///
        /// Returns the signature.
        fn ecdsa_sign_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &ecdsa::Public,
            msg: &[u8],
        ) -> Option<ecdsa::Signature> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ecdsa_sign(id, pub_key, msg)
                .ok()
                .flatten()
        }
        /// Sign the given a pre-hashed `msg` with the `ecdsa` key that corresponds to the given public
        /// key and key type in the keystore.
        ///
        /// Returns the signature.
        fn ecdsa_sign_prehashed_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &ecdsa::Public,
            msg: &[u8; 32],
        ) -> Option<ecdsa::Signature> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ecdsa_sign_prehashed(id, pub_key, msg)
                .ok()
                .flatten()
        }
        /// Verify `ecdsa` signature.
        ///
        /// Returns `true` when the verification was successful.
        /// This version is able to handle, non-standard, overflowing signatures.
        fn ecdsa_verify_version_1(
            sig: &ecdsa::Signature,
            msg: &[u8],
            pub_key: &ecdsa::Public,
        ) -> bool {
            #[allow(deprecated)] ecdsa::Pair::verify_deprecated(sig, msg, pub_key)
        }
        /// Verify `ecdsa` signature.
        ///
        /// Returns `true` when the verification was successful.
        fn ecdsa_verify_version_2(
            sig: &ecdsa::Signature,
            msg: &[u8],
            pub_key: &ecdsa::Public,
        ) -> bool {
            ecdsa::Pair::verify(sig, msg, pub_key)
        }
        /// Verify `ecdsa` signature with pre-hashed `msg`.
        ///
        /// Returns `true` when the verification was successful.
        fn ecdsa_verify_prehashed_version_1(
            sig: &ecdsa::Signature,
            msg: &[u8; 32],
            pub_key: &ecdsa::Public,
        ) -> bool {
            ecdsa::Pair::verify_prehashed(sig, msg, pub_key)
        }
        /// Register a `ed25519` signature for batch verification.
        ///
        /// Batch verification must be enabled by calling [`start_batch_verify`].
        /// If batch verification is not enabled, the signature will be verified immediately.
        /// To get the result of the batch verification, [`finish_batch_verify`]
        /// needs to be called.
        ///
        /// Returns `true` when the verification is either successful or batched.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn ed25519_batch_verify_version_1(
            &mut self,
            sig: &ed25519::Signature,
            msg: &[u8],
            pub_key: &ed25519::Public,
        ) -> bool {
            let res = ed25519_verify(sig, msg, pub_key);
            if let Some(ext) = self.extension::<VerificationExtDeprecated>() {
                ext.0 &= res;
            }
            res
        }
        /// Generate an `ed22519` key for the given key type using an optional `seed` and
        /// store it in the keystore.
        ///
        /// The `seed` needs to be a valid utf8.
        ///
        /// Returns the public key.
        fn ed25519_generate_version_1(
            &mut self,
            id: KeyTypeId,
            seed: Option<Vec<u8>>,
        ) -> ed25519::Public {
            let seed = seed
                .as_ref()
                .map(|s| std::str::from_utf8(s).expect("Seed is valid utf8!"));
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ed25519_generate_new(id, seed)
                .expect("`ed25519_generate` failed")
        }
        /// Returns all `ed25519` public keys for the given key id from the keystore.
        fn ed25519_public_keys_version_1(
            &mut self,
            id: KeyTypeId,
        ) -> Vec<ed25519::Public> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ed25519_public_keys(id)
        }
        /// Sign the given `msg` with the `ed25519` key that corresponds to the given public key and
        /// key type in the keystore.
        ///
        /// Returns the signature.
        fn ed25519_sign_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &ed25519::Public,
            msg: &[u8],
        ) -> Option<ed25519::Signature> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .ed25519_sign(id, pub_key, msg)
                .ok()
                .flatten()
        }
        /// Verify `ed25519` signature.
        ///
        /// Returns `true` when the verification was successful.
        fn ed25519_verify_version_1(
            sig: &ed25519::Signature,
            msg: &[u8],
            pub_key: &ed25519::Public,
        ) -> bool {
            if sp_externalities::with_externalities(|mut e| {
                    e.extension::<UseDalekExt>().is_some()
                })
                .unwrap_or_default()
            {
                use ed25519_dalek::Verifier;
                let Ok(public_key) = ed25519_dalek::VerifyingKey::from_bytes(&pub_key.0)
                else { return false };
                let sig = ed25519_dalek::Signature::from_bytes(&sig.0);
                public_key.verify(msg, &sig).is_ok()
            } else {
                ed25519::Pair::verify(sig, msg, pub_key)
            }
        }
        /// Finish batch-verification of signatures.
        ///
        /// Verify or wait for verification to finish for all signatures which were previously
        /// deferred by `sr25519_verify`/`ed25519_verify`.
        ///
        /// Will panic if no `VerificationExt` is registered (`start_batch_verify` was not called).
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn finish_batch_verify_version_1(&mut self) -> bool {
            let result = self
                .extension::<VerificationExtDeprecated>()
                .expect(
                    "`finish_batch_verify` should only be called after `start_batch_verify`",
                )
                .0;
            self.deregister_extension::<VerificationExtDeprecated>()
                .expect("No verification extension in current context!");
            result
        }
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
        /// (doesn't include the 0x04 prefix).
        /// This version is able to handle, non-standard, overflowing signatures.
        fn secp256k1_ecdsa_recover_version_1(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 64], EcdsaVerifyError> {
            let rid = libsecp256k1::RecoveryId::parse(
                    if sig[64] > 26 { sig[64] - 27 } else { sig[64] } as u8,
                )
                .map_err(|_| EcdsaVerifyError::BadV)?;
            let sig = libsecp256k1::Signature::parse_overflowing_slice(&sig[..64])
                .map_err(|_| EcdsaVerifyError::BadRS)?;
            let msg = libsecp256k1::Message::parse(msg);
            let pubkey = libsecp256k1::recover(&msg, &sig, &rid)
                .map_err(|_| EcdsaVerifyError::BadSignature)?;
            let mut res = [0u8; 64];
            res.copy_from_slice(&pubkey.serialize()[1..65]);
            Ok(res)
        }
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
        /// (doesn't include the 0x04 prefix).
        fn secp256k1_ecdsa_recover_version_2(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 64], EcdsaVerifyError> {
            let rid = RecoveryId::from_i32(
                    if sig[64] > 26 { sig[64] - 27 } else { sig[64] } as i32,
                )
                .map_err(|_| EcdsaVerifyError::BadV)?;
            let sig = RecoverableSignature::from_compact(&sig[..64], rid)
                .map_err(|_| EcdsaVerifyError::BadRS)?;
            let msg = Message::from_digest_slice(msg).expect("Message is 32 bytes; qed");
            let pubkey = SECP256K1
                .recover_ecdsa(&msg, &sig)
                .map_err(|_| EcdsaVerifyError::BadSignature)?;
            let mut res = [0u8; 64];
            res.copy_from_slice(&pubkey.serialize_uncompressed()[1..]);
            Ok(res)
        }
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
        fn secp256k1_ecdsa_recover_compressed_version_1(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 33], EcdsaVerifyError> {
            let rid = libsecp256k1::RecoveryId::parse(
                    if sig[64] > 26 { sig[64] - 27 } else { sig[64] } as u8,
                )
                .map_err(|_| EcdsaVerifyError::BadV)?;
            let sig = libsecp256k1::Signature::parse_overflowing_slice(&sig[0..64])
                .map_err(|_| EcdsaVerifyError::BadRS)?;
            let msg = libsecp256k1::Message::parse(msg);
            let pubkey = libsecp256k1::recover(&msg, &sig, &rid)
                .map_err(|_| EcdsaVerifyError::BadSignature)?;
            Ok(pubkey.serialize_compressed())
        }
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
        fn secp256k1_ecdsa_recover_compressed_version_2(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 33], EcdsaVerifyError> {
            let rid = RecoveryId::from_i32(
                    if sig[64] > 26 { sig[64] - 27 } else { sig[64] } as i32,
                )
                .map_err(|_| EcdsaVerifyError::BadV)?;
            let sig = RecoverableSignature::from_compact(&sig[..64], rid)
                .map_err(|_| EcdsaVerifyError::BadRS)?;
            let msg = Message::from_digest_slice(msg).expect("Message is 32 bytes; qed");
            let pubkey = SECP256K1
                .recover_ecdsa(&msg, &sig)
                .map_err(|_| EcdsaVerifyError::BadSignature)?;
            Ok(pubkey.serialize())
        }
        /// Register a `sr25519` signature for batch verification.
        ///
        /// Batch verification must be enabled by calling [`start_batch_verify`].
        /// If batch verification is not enabled, the signature will be verified immediately.
        /// To get the result of the batch verification, [`finish_batch_verify`]
        /// needs to be called.
        ///
        /// Returns `true` when the verification is either successful or batched.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn sr25519_batch_verify_version_1(
            &mut self,
            sig: &sr25519::Signature,
            msg: &[u8],
            pub_key: &sr25519::Public,
        ) -> bool {
            let res = sr25519_verify(sig, msg, pub_key);
            if let Some(ext) = self.extension::<VerificationExtDeprecated>() {
                ext.0 &= res;
            }
            res
        }
        /// Generate an `sr22519` key for the given key type using an optional seed and
        /// store it in the keystore.
        ///
        /// The `seed` needs to be a valid utf8.
        ///
        /// Returns the public key.
        fn sr25519_generate_version_1(
            &mut self,
            id: KeyTypeId,
            seed: Option<Vec<u8>>,
        ) -> sr25519::Public {
            let seed = seed
                .as_ref()
                .map(|s| std::str::from_utf8(s).expect("Seed is valid utf8!"));
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .sr25519_generate_new(id, seed)
                .expect("`sr25519_generate` failed")
        }
        /// Returns all `sr25519` public keys for the given key id from the keystore.
        fn sr25519_public_keys_version_1(
            &mut self,
            id: KeyTypeId,
        ) -> Vec<sr25519::Public> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .sr25519_public_keys(id)
        }
        /// Sign the given `msg` with the `sr25519` key that corresponds to the given public key and
        /// key type in the keystore.
        ///
        /// Returns the signature.
        fn sr25519_sign_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &sr25519::Public,
            msg: &[u8],
        ) -> Option<sr25519::Signature> {
            self.extension::<KeystoreExt>()
                .expect("No `keystore` associated for the current context!")
                .sr25519_sign(id, pub_key, msg)
                .ok()
                .flatten()
        }
        /// Verify an `sr25519` signature.
        ///
        /// Returns `true` when the verification in successful regardless of
        /// signature version.
        fn sr25519_verify_version_1(
            sig: &sr25519::Signature,
            msg: &[u8],
            pubkey: &sr25519::Public,
        ) -> bool {
            sr25519::Pair::verify_deprecated(sig, msg, pubkey)
        }
        /// Verify `sr25519` signature.
        ///
        /// Returns `true` when the verification was successful.
        fn sr25519_verify_version_2(
            sig: &sr25519::Signature,
            msg: &[u8],
            pub_key: &sr25519::Public,
        ) -> bool {
            sr25519::Pair::verify(sig, msg, pub_key)
        }
        /// Start verification extension.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn start_batch_verify_version_1(&mut self) {
            self.register_extension(VerificationExtDeprecated(true))
                .expect("Failed to register required extension: `VerificationExt`");
        }
    }
    trait Crypto {
        /// Register a `ecdsa` signature for batch verification.
        ///
        /// Batch verification must be enabled by calling [`start_batch_verify`].
        /// If batch verification is not enabled, the signature will be verified immediatley.
        /// To get the result of the batch verification, [`finish_batch_verify`]
        /// needs to be called.
        ///
        /// Returns `true` when the verification is either successful or batched.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn ecdsa_batch_verify_version_1(
            &mut self,
            sig: &ecdsa::Signature,
            msg: &[u8],
            pub_key: &ecdsa::Public,
        ) -> bool;
        /// Generate an `ecdsa` key for the given key type using an optional `seed` and
        /// store it in the keystore.
        ///
        /// The `seed` needs to be a valid utf8.
        ///
        /// Returns the public key.
        fn ecdsa_generate_version_1(
            &mut self,
            id: KeyTypeId,
            seed: Option<Vec<u8>>,
        ) -> ecdsa::Public;
        /// Returns all `ecdsa` public keys for the given key id from the keystore.
        fn ecdsa_public_keys_version_1(&mut self, id: KeyTypeId) -> Vec<ecdsa::Public>;
        /// Sign the given `msg` with the `ecdsa` key that corresponds to the given public key and
        /// key type in the keystore.
        ///
        /// Returns the signature.
        fn ecdsa_sign_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &ecdsa::Public,
            msg: &[u8],
        ) -> Option<ecdsa::Signature>;
        /// Sign the given a pre-hashed `msg` with the `ecdsa` key that corresponds to the given public
        /// key and key type in the keystore.
        ///
        /// Returns the signature.
        fn ecdsa_sign_prehashed_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &ecdsa::Public,
            msg: &[u8; 32],
        ) -> Option<ecdsa::Signature>;
        /// Verify `ecdsa` signature.
        ///
        /// Returns `true` when the verification was successful.
        /// This version is able to handle, non-standard, overflowing signatures.
        fn ecdsa_verify_version_1(
            sig: &ecdsa::Signature,
            msg: &[u8],
            pub_key: &ecdsa::Public,
        ) -> bool;
        /// Verify `ecdsa` signature.
        ///
        /// Returns `true` when the verification was successful.
        fn ecdsa_verify_version_2(
            sig: &ecdsa::Signature,
            msg: &[u8],
            pub_key: &ecdsa::Public,
        ) -> bool;
        /// Verify `ecdsa` signature with pre-hashed `msg`.
        ///
        /// Returns `true` when the verification was successful.
        fn ecdsa_verify_prehashed_version_1(
            sig: &ecdsa::Signature,
            msg: &[u8; 32],
            pub_key: &ecdsa::Public,
        ) -> bool;
        /// Register a `ed25519` signature for batch verification.
        ///
        /// Batch verification must be enabled by calling [`start_batch_verify`].
        /// If batch verification is not enabled, the signature will be verified immediately.
        /// To get the result of the batch verification, [`finish_batch_verify`]
        /// needs to be called.
        ///
        /// Returns `true` when the verification is either successful or batched.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn ed25519_batch_verify_version_1(
            &mut self,
            sig: &ed25519::Signature,
            msg: &[u8],
            pub_key: &ed25519::Public,
        ) -> bool;
        /// Generate an `ed22519` key for the given key type using an optional `seed` and
        /// store it in the keystore.
        ///
        /// The `seed` needs to be a valid utf8.
        ///
        /// Returns the public key.
        fn ed25519_generate_version_1(
            &mut self,
            id: KeyTypeId,
            seed: Option<Vec<u8>>,
        ) -> ed25519::Public;
        /// Returns all `ed25519` public keys for the given key id from the keystore.
        fn ed25519_public_keys_version_1(
            &mut self,
            id: KeyTypeId,
        ) -> Vec<ed25519::Public>;
        /// Sign the given `msg` with the `ed25519` key that corresponds to the given public key and
        /// key type in the keystore.
        ///
        /// Returns the signature.
        fn ed25519_sign_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &ed25519::Public,
            msg: &[u8],
        ) -> Option<ed25519::Signature>;
        /// Verify `ed25519` signature.
        ///
        /// Returns `true` when the verification was successful.
        fn ed25519_verify_version_1(
            sig: &ed25519::Signature,
            msg: &[u8],
            pub_key: &ed25519::Public,
        ) -> bool;
        /// Finish batch-verification of signatures.
        ///
        /// Verify or wait for verification to finish for all signatures which were previously
        /// deferred by `sr25519_verify`/`ed25519_verify`.
        ///
        /// Will panic if no `VerificationExt` is registered (`start_batch_verify` was not called).
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn finish_batch_verify_version_1(&mut self) -> bool;
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
        /// (doesn't include the 0x04 prefix).
        /// This version is able to handle, non-standard, overflowing signatures.
        fn secp256k1_ecdsa_recover_version_1(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 64], EcdsaVerifyError>;
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 64-byte pubkey
        /// (doesn't include the 0x04 prefix).
        fn secp256k1_ecdsa_recover_version_2(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 64], EcdsaVerifyError>;
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
        fn secp256k1_ecdsa_recover_compressed_version_1(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 33], EcdsaVerifyError>;
        /// Verify and recover a SECP256k1 ECDSA signature.
        ///
        /// - `sig` is passed in RSV format. V should be either `0/1` or `27/28`.
        /// - `msg` is the blake2-256 hash of the message.
        ///
        /// Returns `Err` if the signature is bad, otherwise the 33-byte compressed pubkey.
        fn secp256k1_ecdsa_recover_compressed_version_2(
            sig: &[u8; 65],
            msg: &[u8; 32],
        ) -> Result<[u8; 33], EcdsaVerifyError>;
        /// Register a `sr25519` signature for batch verification.
        ///
        /// Batch verification must be enabled by calling [`start_batch_verify`].
        /// If batch verification is not enabled, the signature will be verified immediately.
        /// To get the result of the batch verification, [`finish_batch_verify`]
        /// needs to be called.
        ///
        /// Returns `true` when the verification is either successful or batched.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn sr25519_batch_verify_version_1(
            &mut self,
            sig: &sr25519::Signature,
            msg: &[u8],
            pub_key: &sr25519::Public,
        ) -> bool;
        /// Generate an `sr22519` key for the given key type using an optional seed and
        /// store it in the keystore.
        ///
        /// The `seed` needs to be a valid utf8.
        ///
        /// Returns the public key.
        fn sr25519_generate_version_1(
            &mut self,
            id: KeyTypeId,
            seed: Option<Vec<u8>>,
        ) -> sr25519::Public;
        /// Returns all `sr25519` public keys for the given key id from the keystore.
        fn sr25519_public_keys_version_1(
            &mut self,
            id: KeyTypeId,
        ) -> Vec<sr25519::Public>;
        /// Sign the given `msg` with the `sr25519` key that corresponds to the given public key and
        /// key type in the keystore.
        ///
        /// Returns the signature.
        fn sr25519_sign_version_1(
            &mut self,
            id: KeyTypeId,
            pub_key: &sr25519::Public,
            msg: &[u8],
        ) -> Option<sr25519::Signature>;
        /// Verify an `sr25519` signature.
        ///
        /// Returns `true` when the verification in successful regardless of
        /// signature version.
        fn sr25519_verify_version_1(
            sig: &sr25519::Signature,
            msg: &[u8],
            pubkey: &sr25519::Public,
        ) -> bool;
        /// Verify `sr25519` signature.
        ///
        /// Returns `true` when the verification was successful.
        fn sr25519_verify_version_2(
            sig: &sr25519::Signature,
            msg: &[u8],
            pub_key: &sr25519::Public,
        ) -> bool;
        /// Start verification extension.
        ///
        /// NOTE: Is tagged with `register_only` to keep the functions around for backwards
        /// compatibility with old runtimes, but it should not be used anymore by new runtimes.
        /// The implementation emulates the old behavior, but isn't doing any batch verification
        /// anymore.
        fn start_batch_verify_version_1(&mut self);
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaBatchVerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaBatchVerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <ecdsa::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ecdsa::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_batch_verify_version_1(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaBatchVerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_batch_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'ecdsa_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ecdsa_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ecdsa_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaGenerateVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaGenerateVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            seed_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_generate' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut seed = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    seed_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'seed' argument through the WASM FFI boundary while executing 'ecdsa_generate' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_generate_version_1(id, seed);
            let __result__ = <ecdsa::Public as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaGenerateVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_generate_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ecdsa_generate' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_generate' from interface 'Crypto'"
                        .to_owned()
                })?;
            let seed_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'seed': number of arguments given to 'ecdsa_generate' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let seed_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    seed_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'seed' argument through the WASM FFI boundary while executing 'ecdsa_generate' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                seed_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaPublicKeysVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaPublicKeysVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<ecdsa::Public> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_public_keys' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_public_keys_version_1(id);
            let __result__ = <Vec<
                ecdsa::Public,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaPublicKeysVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_public_keys_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        ecdsa::Public,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ecdsa_public_keys' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_public_keys' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, id_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaSignVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaSignVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<ecdsa::Signature> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ecdsa::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_sign_version_1(id, &pub_key, &msg);
            let __result__ = <Option<
                ecdsa::Signature,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaSignVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_sign_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        ecdsa::Signature,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ecdsa_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ecdsa_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ecdsa_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                pub_key_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaSignPrehashedVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaSignPrehashedVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<ecdsa::Signature> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_sign_prehashed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ecdsa::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_sign_prehashed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_sign_prehashed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_sign_prehashed_version_1(id, &pub_key, &msg);
            let __result__ = <Option<
                ecdsa::Signature,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaSignPrehashedVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_sign_prehashed_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        ecdsa::Signature,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ecdsa_sign_prehashed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ecdsa_sign_prehashed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ecdsa_sign_prehashed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_sign_prehashed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ecdsa_sign_prehashed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_sign_prehashed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                pub_key_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaVerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaVerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <ecdsa::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ecdsa::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_verify_version_1(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaVerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'ecdsa_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ecdsa_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ecdsa_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaVerifyVersion2;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaVerifyVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <ecdsa::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ecdsa::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_verify_version_2(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaVerifyVersion2 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_verify_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'ecdsa_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ecdsa_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ecdsa_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEcdsaVerifyPrehashedVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEcdsaVerifyPrehashedVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <ecdsa::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_verify_prehashed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_verify_prehashed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ecdsa::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_verify_prehashed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ecdsa_verify_prehashed_version_1(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEcdsaVerifyPrehashedVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ecdsa_verify_prehashed_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'ecdsa_verify_prehashed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ecdsa_verify_prehashed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ecdsa_verify_prehashed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ecdsa_verify_prehashed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ecdsa_verify_prehashed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ecdsa_verify_prehashed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEd25519BatchVerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEd25519BatchVerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <ed25519::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ed25519_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ed25519_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ed25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ed25519_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ed25519_batch_verify_version_1(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEd25519BatchVerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ed25519_batch_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'ed25519_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ed25519_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ed25519_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ed25519_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ed25519_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ed25519_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEd25519GenerateVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEd25519GenerateVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            seed_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ed25519_generate' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut seed = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    seed_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'seed' argument through the WASM FFI boundary while executing 'ed25519_generate' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ed25519_generate_version_1(id, seed);
            let __result__ = <ed25519::Public as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEd25519GenerateVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ed25519_generate_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ed25519_generate' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ed25519_generate' from interface 'Crypto'"
                        .to_owned()
                })?;
            let seed_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'seed': number of arguments given to 'ed25519_generate' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let seed_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    seed_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'seed' argument through the WASM FFI boundary while executing 'ed25519_generate' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                seed_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEd25519PublicKeysVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEd25519PublicKeysVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<ed25519::Public> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ed25519_public_keys' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ed25519_public_keys_version_1(id);
            let __result__ = <Vec<
                ed25519::Public,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEd25519PublicKeysVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ed25519_public_keys_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        ed25519::Public,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ed25519_public_keys' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ed25519_public_keys' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, id_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEd25519SignVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEd25519SignVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<
                ed25519::Signature,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ed25519_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ed25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ed25519_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ed25519_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ed25519_sign_version_1(id, &pub_key, &msg);
            let __result__ = <Option<
                ed25519::Signature,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEd25519SignVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ed25519_sign_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        ed25519::Signature,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'ed25519_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'ed25519_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ed25519_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ed25519_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ed25519_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ed25519_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                pub_key_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoEd25519VerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoEd25519VerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <ed25519::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ed25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ed25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <ed25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ed25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = ed25519_verify_version_1(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoEd25519VerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_ed25519_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'ed25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'ed25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'ed25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'ed25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'ed25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'ed25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoFinishBatchVerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoFinishBatchVerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = finish_batch_verify_version_1();
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoFinishBatchVerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_finish_batch_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSecp256K1EcdsaRecoverVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSecp256K1EcdsaRecoverVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<
                [u8; 64],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <[u8; 65] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = secp256k1_ecdsa_recover_version_1(&sig, &msg);
            let __result__ = <Result<
                [u8; 64],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSecp256K1EcdsaRecoverVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_secp256k1_ecdsa_recover_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        [u8; 64],
                        EcdsaVerifyError,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'secp256k1_ecdsa_recover' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'secp256k1_ecdsa_recover' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSecp256K1EcdsaRecoverVersion2;
    #[cfg(feature = "std")]
    impl ExtCryptoSecp256K1EcdsaRecoverVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<
                [u8; 64],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <[u8; 65] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = secp256k1_ecdsa_recover_version_2(&sig, &msg);
            let __result__ = <Result<
                [u8; 64],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSecp256K1EcdsaRecoverVersion2 {
        fn name(&self) -> &str {
            "ext_crypto_secp256k1_ecdsa_recover_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        [u8; 64],
                        EcdsaVerifyError,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'secp256k1_ecdsa_recover' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'secp256k1_ecdsa_recover' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSecp256K1EcdsaRecoverCompressedVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSecp256K1EcdsaRecoverCompressedVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<
                [u8; 33],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <[u8; 65] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = secp256k1_ecdsa_recover_compressed_version_1(&sig, &msg);
            let __result__ = <Result<
                [u8; 33],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSecp256K1EcdsaRecoverCompressedVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_secp256k1_ecdsa_recover_compressed_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        [u8; 33],
                        EcdsaVerifyError,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSecp256K1EcdsaRecoverCompressedVersion2;
    #[cfg(feature = "std")]
    impl ExtCryptoSecp256K1EcdsaRecoverCompressedVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<
                [u8; 33],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <[u8; 65] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = secp256k1_ecdsa_recover_compressed_version_2(&sig, &msg);
            let __result__ = <Result<
                [u8; 33],
                EcdsaVerifyError,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSecp256K1EcdsaRecoverCompressedVersion2 {
        fn name(&self) -> &str {
            "ext_crypto_secp256k1_ecdsa_recover_compressed_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        [u8; 33],
                        EcdsaVerifyError,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'secp256k1_ecdsa_recover_compressed' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSr25519BatchVerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSr25519BatchVerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <sr25519::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'sr25519_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <sr25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'sr25519_batch_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = sr25519_batch_verify_version_1(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSr25519BatchVerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_sr25519_batch_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'sr25519_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'sr25519_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'sr25519_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'sr25519_batch_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'sr25519_batch_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSr25519GenerateVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSr25519GenerateVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            seed_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'sr25519_generate' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut seed = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    seed_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'seed' argument through the WASM FFI boundary while executing 'sr25519_generate' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = sr25519_generate_version_1(id, seed);
            let __result__ = <sr25519::Public as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSr25519GenerateVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_sr25519_generate_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'sr25519_generate' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'sr25519_generate' from interface 'Crypto'"
                        .to_owned()
                })?;
            let seed_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'seed': number of arguments given to 'sr25519_generate' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let seed_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    seed_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'seed' argument through the WASM FFI boundary while executing 'sr25519_generate' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                seed_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSr25519PublicKeysVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSr25519PublicKeysVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<sr25519::Public> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'sr25519_public_keys' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = sr25519_public_keys_version_1(id);
            let __result__ = <Vec<
                sr25519::Public,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSr25519PublicKeysVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_sr25519_public_keys_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        sr25519::Public,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'sr25519_public_keys' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'sr25519_public_keys' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, id_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSr25519SignVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSr25519SignVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<
                sr25519::Signature,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut id = <KeyTypeId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'id' argument through the WASM FFI boundary while executing 'sr25519_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <sr25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'sr25519_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_sign' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = sr25519_sign_version_1(id, &pub_key, &msg);
            let __result__ = <Option<
                sr25519::Signature,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSr25519SignVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_sr25519_sign_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        sr25519::Signature,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'id': number of arguments given to 'sr25519_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'id' argument through the WASM FFI boundary while executing 'sr25519_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'sr25519_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'sr25519_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'sr25519_sign' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_sign' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                id_ffi_value,
                pub_key_ffi_value,
                msg_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSr25519VerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoSr25519VerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pubkey_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <sr25519::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pubkey = <sr25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pubkey_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pubkey' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = sr25519_verify_version_1(&sig, &msg, &pubkey);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSr25519VerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_sr25519_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'sr25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'sr25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pubkey_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pubkey': number of arguments given to 'sr25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pubkey_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pubkey_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pubkey' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pubkey_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoSr25519VerifyVersion2;
    #[cfg(feature = "std")]
    impl ExtCryptoSr25519VerifyVersion2 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
            msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut sig = <sr25519::Signature as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    sig_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut msg = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    msg_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let mut pub_key = <sr25519::Public as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    pub_key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'",
                        ),
                    );
                    res
                })?;
            let __result__ = sr25519_verify_version_2(&sig, &msg, &pub_key);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoSr25519VerifyVersion2 {
        fn name(&self) -> &str {
            "ext_crypto_sr25519_verify_version_2"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let sig_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'sig': number of arguments given to 'sr25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    sig_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'sig' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let msg_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'msg': number of arguments given to 'sr25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    msg_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'msg' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let pub_key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'pub_key': number of arguments given to 'sr25519_verify' from interface 'Crypto' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    pub_key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'pub_key' argument through the WASM FFI boundary while executing 'sr25519_verify' from interface 'Crypto'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                sig_ffi_value,
                msg_ffi_value,
                pub_key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtCryptoStartBatchVerifyVersion1;
    #[cfg(feature = "std")]
    impl ExtCryptoStartBatchVerifyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<(), String> {
            let __result__ = start_batch_verify_version_1();
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtCryptoStartBatchVerifyVersion1 {
        fn name(&self) -> &str {
            "ext_crypto_start_batch_verify_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtCryptoEcdsaBatchVerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaGenerateVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaPublicKeysVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaSignVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaSignPrehashedVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaVerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaVerifyVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEcdsaVerifyPrehashedVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEd25519BatchVerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEd25519GenerateVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEd25519PublicKeysVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEd25519SignVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoEd25519VerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoFinishBatchVerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSecp256K1EcdsaRecoverVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSecp256K1EcdsaRecoverVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSecp256K1EcdsaRecoverCompressedVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSecp256K1EcdsaRecoverCompressedVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSr25519BatchVerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSr25519GenerateVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSr25519PublicKeysVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSr25519SignVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSr25519VerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoSr25519VerifyVersion2
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtCryptoStartBatchVerifyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaBatchVerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaBatchVerifyVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaGenerateVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        seed_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaGenerateVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                seed_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaPublicKeysVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<
                            ecdsa::Public,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaPublicKeysVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaSignVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            ecdsa::Signature,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaSignVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                pub_key_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaSignPrehashedVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            ecdsa::Signature,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaSignPrehashedVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                pub_key_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaVerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaVerifyVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaVerifyVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaVerifyVersion2::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEcdsaVerifyPrehashedVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <ecdsa::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ecdsa::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEcdsaVerifyPrehashedVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEd25519BatchVerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEd25519BatchVerifyVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEd25519GenerateVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        seed_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEd25519GenerateVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                seed_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEd25519PublicKeysVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<
                            ed25519::Public,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEd25519PublicKeysVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEd25519SignVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            ed25519::Signature,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEd25519SignVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                pub_key_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoEd25519VerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <ed25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <ed25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoEd25519VerifyVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoFinishBatchVerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoFinishBatchVerifyVersion1::call(
                                                __function_context__,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSecp256K1EcdsaRecoverVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            [u8; 64],
                            EcdsaVerifyError,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSecp256K1EcdsaRecoverVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSecp256K1EcdsaRecoverVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            [u8; 64],
                            EcdsaVerifyError,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSecp256K1EcdsaRecoverVersion2::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSecp256K1EcdsaRecoverCompressedVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            [u8; 33],
                            EcdsaVerifyError,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSecp256K1EcdsaRecoverCompressedVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSecp256K1EcdsaRecoverCompressedVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <[u8; 65] as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            [u8; 33],
                            EcdsaVerifyError,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSecp256K1EcdsaRecoverCompressedVersion2::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSr25519BatchVerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSr25519BatchVerifyVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSr25519GenerateVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        seed_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSr25519GenerateVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                seed_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSr25519PublicKeysVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<
                            sr25519::Public,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSr25519PublicKeysVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSr25519SignVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        id_ffi_value: <KeyTypeId as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            sr25519::Signature,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSr25519SignVersion1::call(
                                                __function_context__,
                                                id_ffi_value,
                                                pub_key_ffi_value,
                                                msg_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSr25519VerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pubkey_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSr25519VerifyVersion1::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pubkey_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoSr25519VerifyVersion2,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        sig_ffi_value: <sr25519::Signature as proc_macro_runtime_interface::RIType>::FFIType,
                        msg_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        pub_key_ffi_value: <sr25519::Public as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoSr25519VerifyVersion2::call(
                                                __function_context__,
                                                sig_ffi_value,
                                                msg_ffi_value,
                                                pub_key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtCryptoStartBatchVerifyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtCryptoStartBatchVerifyVersion1::call(
                                                __function_context__,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface that provides functions for hashing with different algorithms.
pub mod hashing {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Conduct a 128-bit Blake2 hash.
    pub fn blake2_128(data: &[u8]) -> [u8; 16] {
        blake2_128_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct a 256-bit Blake2 hash.
    pub fn blake2_256(data: &[u8]) -> [u8; 32] {
        blake2_256_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct a 256-bit Keccak hash.
    pub fn keccak_256(data: &[u8]) -> [u8; 32] {
        keccak_256_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct a 512-bit Keccak hash.
    pub fn keccak_512(data: &[u8]) -> [u8; 64] {
        keccak_512_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct a 256-bit Sha2 hash.
    pub fn sha2_256(data: &[u8]) -> [u8; 32] {
        sha2_256_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct two XX hashes to give a 128-bit result.
    pub fn twox_128(data: &[u8]) -> [u8; 16] {
        twox_128_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct four XX hashes to give a 256-bit result.
    pub fn twox_256(data: &[u8]) -> [u8; 32] {
        twox_256_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct two XX hashes to give a 64-bit result.
    pub fn twox_64(data: &[u8]) -> [u8; 8] {
        twox_64_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Conduct a 128-bit Blake2 hash.
    fn blake2_128_version_1(data: &[u8]) -> [u8; 16] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_128_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::blake2_128_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct a 256-bit Blake2 hash.
    fn blake2_256_version_1(data: &[u8]) -> [u8; 32] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "blake2_256_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::blake2_256_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct a 256-bit Keccak hash.
    fn keccak_256_version_1(data: &[u8]) -> [u8; 32] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_256_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::keccak_256_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct a 512-bit Keccak hash.
    fn keccak_512_version_1(data: &[u8]) -> [u8; 64] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "keccak_512_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::keccak_512_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct a 256-bit Sha2 hash.
    fn sha2_256_version_1(data: &[u8]) -> [u8; 32] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sha2_256_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::sha2_256_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct two XX hashes to give a 128-bit result.
    fn twox_128_version_1(data: &[u8]) -> [u8; 16] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "twox_128_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::twox_128_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct four XX hashes to give a 256-bit result.
    fn twox_256_version_1(data: &[u8]) -> [u8; 32] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "twox_256_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::twox_256_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct two XX hashes to give a 64-bit result.
    fn twox_64_version_1(data: &[u8]) -> [u8; 8] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "twox_64_version_1",
                        "sp_io::hashing",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1250u32),
                        ::core::option::Option::Some("sp_io::hashing"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Hashing>::twox_64_version_1(
                    data,
                )
            })
    }
    #[cfg(feature = "std")]
    impl Hashing for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Conduct a 128-bit Blake2 hash.
        fn blake2_128_version_1(data: &[u8]) -> [u8; 16] {
            sp_core::hashing::blake2_128(data)
        }
        /// Conduct a 256-bit Blake2 hash.
        fn blake2_256_version_1(data: &[u8]) -> [u8; 32] {
            sp_core::hashing::blake2_256(data)
        }
        /// Conduct a 256-bit Keccak hash.
        fn keccak_256_version_1(data: &[u8]) -> [u8; 32] {
            sp_core::hashing::keccak_256(data)
        }
        /// Conduct a 512-bit Keccak hash.
        fn keccak_512_version_1(data: &[u8]) -> [u8; 64] {
            sp_core::hashing::keccak_512(data)
        }
        /// Conduct a 256-bit Sha2 hash.
        fn sha2_256_version_1(data: &[u8]) -> [u8; 32] {
            sp_core::hashing::sha2_256(data)
        }
        /// Conduct two XX hashes to give a 128-bit result.
        fn twox_128_version_1(data: &[u8]) -> [u8; 16] {
            sp_core::hashing::twox_128(data)
        }
        /// Conduct four XX hashes to give a 256-bit result.
        fn twox_256_version_1(data: &[u8]) -> [u8; 32] {
            sp_core::hashing::twox_256(data)
        }
        /// Conduct two XX hashes to give a 64-bit result.
        fn twox_64_version_1(data: &[u8]) -> [u8; 8] {
            sp_core::hashing::twox_64(data)
        }
    }
    trait Hashing {
        /// Conduct a 128-bit Blake2 hash.
        fn blake2_128_version_1(data: &[u8]) -> [u8; 16];
        /// Conduct a 256-bit Blake2 hash.
        fn blake2_256_version_1(data: &[u8]) -> [u8; 32];
        /// Conduct a 256-bit Keccak hash.
        fn keccak_256_version_1(data: &[u8]) -> [u8; 32];
        /// Conduct a 512-bit Keccak hash.
        fn keccak_512_version_1(data: &[u8]) -> [u8; 64];
        /// Conduct a 256-bit Sha2 hash.
        fn sha2_256_version_1(data: &[u8]) -> [u8; 32];
        /// Conduct two XX hashes to give a 128-bit result.
        fn twox_128_version_1(data: &[u8]) -> [u8; 16];
        /// Conduct four XX hashes to give a 256-bit result.
        fn twox_256_version_1(data: &[u8]) -> [u8; 32];
        /// Conduct two XX hashes to give a 64-bit result.
        fn twox_64_version_1(data: &[u8]) -> [u8; 8];
    }
    #[cfg(feature = "std")]
    struct ExtHashingBlake2128Version1;
    #[cfg(feature = "std")]
    impl ExtHashingBlake2128Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 16] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'blake2_128' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_128_version_1(&data);
            let __result__ = <[u8; 16] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingBlake2128Version1 {
        fn name(&self) -> &str {
            "ext_hashing_blake2_128_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 16] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'blake2_128' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'blake2_128' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingBlake2256Version1;
    #[cfg(feature = "std")]
    impl ExtHashingBlake2256Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'blake2_256' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = blake2_256_version_1(&data);
            let __result__ = <[u8; 32] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingBlake2256Version1 {
        fn name(&self) -> &str {
            "ext_hashing_blake2_256_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'blake2_256' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'blake2_256' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingKeccak256Version1;
    #[cfg(feature = "std")]
    impl ExtHashingKeccak256Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'keccak_256' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_256_version_1(&data);
            let __result__ = <[u8; 32] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingKeccak256Version1 {
        fn name(&self) -> &str {
            "ext_hashing_keccak_256_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'keccak_256' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'keccak_256' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingKeccak512Version1;
    #[cfg(feature = "std")]
    impl ExtHashingKeccak512Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 64] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'keccak_512' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = keccak_512_version_1(&data);
            let __result__ = <[u8; 64] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingKeccak512Version1 {
        fn name(&self) -> &str {
            "ext_hashing_keccak_512_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 64] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'keccak_512' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'keccak_512' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingSha2256Version1;
    #[cfg(feature = "std")]
    impl ExtHashingSha2256Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'sha2_256' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = sha2_256_version_1(&data);
            let __result__ = <[u8; 32] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingSha2256Version1 {
        fn name(&self) -> &str {
            "ext_hashing_sha2_256_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'sha2_256' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'sha2_256' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingTwox128Version1;
    #[cfg(feature = "std")]
    impl ExtHashingTwox128Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 16] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'twox_128' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = twox_128_version_1(&data);
            let __result__ = <[u8; 16] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingTwox128Version1 {
        fn name(&self) -> &str {
            "ext_hashing_twox_128_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 16] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'twox_128' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'twox_128' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingTwox256Version1;
    #[cfg(feature = "std")]
    impl ExtHashingTwox256Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'twox_256' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = twox_256_version_1(&data);
            let __result__ = <[u8; 32] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingTwox256Version1 {
        fn name(&self) -> &str {
            "ext_hashing_twox_256_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'twox_256' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'twox_256' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtHashingTwox64Version1;
    #[cfg(feature = "std")]
    impl ExtHashingTwox64Version1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <[u8; 8] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'twox_64' from interface 'Hashing'",
                        ),
                    );
                    res
                })?;
            let __result__ = twox_64_version_1(&data);
            let __result__ = <[u8; 8] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtHashingTwox64Version1 {
        fn name(&self) -> &str {
            "ext_hashing_twox_64_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<[u8; 8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'twox_64' from interface 'Hashing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'twox_64' from interface 'Hashing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtHashingBlake2128Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingBlake2256Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingKeccak256Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingKeccak512Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingSha2256Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingTwox128Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingTwox256Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtHashingTwox64Version1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingBlake2128Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 16] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingBlake2128Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingBlake2256Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingBlake2256Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingKeccak256Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingKeccak256Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingKeccak512Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 64] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingKeccak512Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingSha2256Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingSha2256Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingTwox128Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 16] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingTwox128Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingTwox256Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingTwox256Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtHashingTwox64Version1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <[u8; 8] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtHashingTwox64Version1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface that provides transaction indexing API.
pub mod transaction_index {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Add transaction index. Returns indexed content hash.
    pub fn index(extrinsic: u32, size: u32, context_hash: [u8; 32]) {
        index_version_1(extrinsic, size, context_hash)
    }
    #[cfg(feature = "std")]
    /// Conduct a 512-bit Keccak hash.
    pub fn renew(extrinsic: u32, context_hash: [u8; 32]) {
        renew_version_1(extrinsic, context_hash)
    }
    #[cfg(feature = "std")]
    /// Add transaction index. Returns indexed content hash.
    fn index_version_1(extrinsic: u32, size: u32, context_hash: [u8; 32]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "index_version_1",
                        "sp_io::transaction_index",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1294u32),
                        ::core::option::Option::Some("sp_io::transaction_index"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| TransactionIndex::index_version_1(
                        &mut __externalities__,
                        extrinsic,
                        size,
                        context_hash,
                    ))
                    .expect(
                        "`index_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Conduct a 512-bit Keccak hash.
    fn renew_version_1(extrinsic: u32, context_hash: [u8; 32]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "renew_version_1",
                        "sp_io::transaction_index",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1294u32),
                        ::core::option::Option::Some("sp_io::transaction_index"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| TransactionIndex::renew_version_1(
                        &mut __externalities__,
                        extrinsic,
                        context_hash,
                    ))
                    .expect(
                        "`renew_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl TransactionIndex for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Add transaction index. Returns indexed content hash.
        fn index_version_1(
            &mut self,
            extrinsic: u32,
            size: u32,
            context_hash: [u8; 32],
        ) {
            self.storage_index_transaction(extrinsic, &context_hash, size);
        }
        /// Conduct a 512-bit Keccak hash.
        fn renew_version_1(&mut self, extrinsic: u32, context_hash: [u8; 32]) {
            self.storage_renew_transaction_index(extrinsic, &context_hash);
        }
    }
    trait TransactionIndex {
        /// Add transaction index. Returns indexed content hash.
        fn index_version_1(&mut self, extrinsic: u32, size: u32, context_hash: [u8; 32]);
        /// Conduct a 512-bit Keccak hash.
        fn renew_version_1(&mut self, extrinsic: u32, context_hash: [u8; 32]);
    }
    #[cfg(feature = "std")]
    struct ExtTransactionIndexIndexVersion1;
    #[cfg(feature = "std")]
    impl ExtTransactionIndexIndexVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            extrinsic_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
            size_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
            context_hash_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut extrinsic = <u32 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    extrinsic_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'extrinsic' argument through the WASM FFI boundary while executing 'index' from interface 'TransactionIndex'",
                        ),
                    );
                    res
                })?;
            let mut size = <u32 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    size_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'size' argument through the WASM FFI boundary while executing 'index' from interface 'TransactionIndex'",
                        ),
                    );
                    res
                })?;
            let mut context_hash = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    context_hash_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'context_hash' argument through the WASM FFI boundary while executing 'index' from interface 'TransactionIndex'",
                        ),
                    );
                    res
                })?;
            let __result__ = index_version_1(extrinsic, size, context_hash);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTransactionIndexIndexVersion1 {
        fn name(&self) -> &str {
            "ext_transaction_index_index_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<u32 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<u32 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let extrinsic_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'extrinsic': number of arguments given to 'index' from interface 'TransactionIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let extrinsic_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    extrinsic_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'extrinsic' argument through the WASM FFI boundary while executing 'index' from interface 'TransactionIndex'"
                        .to_owned()
                })?;
            let size_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'size': number of arguments given to 'index' from interface 'TransactionIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let size_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    size_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'size' argument through the WASM FFI boundary while executing 'index' from interface 'TransactionIndex'"
                        .to_owned()
                })?;
            let context_hash_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'context_hash': number of arguments given to 'index' from interface 'TransactionIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let context_hash_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    context_hash_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'context_hash' argument through the WASM FFI boundary while executing 'index' from interface 'TransactionIndex'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                extrinsic_ffi_value,
                size_ffi_value,
                context_hash_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtTransactionIndexRenewVersion1;
    #[cfg(feature = "std")]
    impl ExtTransactionIndexRenewVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            extrinsic_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
            context_hash_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut extrinsic = <u32 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    extrinsic_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'extrinsic' argument through the WASM FFI boundary while executing 'renew' from interface 'TransactionIndex'",
                        ),
                    );
                    res
                })?;
            let mut context_hash = <[u8; 32] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    context_hash_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'context_hash' argument through the WASM FFI boundary while executing 'renew' from interface 'TransactionIndex'",
                        ),
                    );
                    res
                })?;
            let __result__ = renew_version_1(extrinsic, context_hash);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtTransactionIndexRenewVersion1 {
        fn name(&self) -> &str {
            "ext_transaction_index_renew_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<u32 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let extrinsic_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'extrinsic': number of arguments given to 'renew' from interface 'TransactionIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let extrinsic_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    extrinsic_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'extrinsic' argument through the WASM FFI boundary while executing 'renew' from interface 'TransactionIndex'"
                        .to_owned()
                })?;
            let context_hash_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'context_hash': number of arguments given to 'renew' from interface 'TransactionIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let context_hash_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    context_hash_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'context_hash' argument through the WASM FFI boundary while executing 'renew' from interface 'TransactionIndex'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                extrinsic_ffi_value,
                context_hash_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtTransactionIndexIndexVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtTransactionIndexRenewVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTransactionIndexIndexVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        extrinsic_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
                        size_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
                        context_hash_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTransactionIndexIndexVersion1::call(
                                                __function_context__,
                                                extrinsic_ffi_value,
                                                size_ffi_value,
                                                context_hash_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtTransactionIndexRenewVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        extrinsic_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
                        context_hash_ffi_value: <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtTransactionIndexRenewVersion1::call(
                                                __function_context__,
                                                extrinsic_ffi_value,
                                                context_hash_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface that provides functions to access the Offchain DB.
pub mod offchain_index {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Remove a key and its associated value from the Offchain DB.
    pub fn clear(key: &[u8]) {
        clear_version_1(key)
    }
    #[cfg(feature = "std")]
    /// Write a key value pair to the Offchain DB database in a buffered fashion.
    pub fn set(key: &[u8], value: &[u8]) {
        set_version_1(key, value)
    }
    #[cfg(feature = "std")]
    /// Remove a key and its associated value from the Offchain DB.
    fn clear_version_1(key: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "clear_version_1",
                        "sp_io::offchain_index",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1308u32),
                        ::core::option::Option::Some("sp_io::offchain_index"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| OffchainIndex::clear_version_1(
                        &mut __externalities__,
                        key,
                    ))
                    .expect(
                        "`clear_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Write a key value pair to the Offchain DB database in a buffered fashion.
    fn set_version_1(key: &[u8], value: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "set_version_1",
                        "sp_io::offchain_index",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1308u32),
                        ::core::option::Option::Some("sp_io::offchain_index"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| OffchainIndex::set_version_1(
                        &mut __externalities__,
                        key,
                        value,
                    ))
                    .expect(
                        "`set_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl OffchainIndex for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Remove a key and its associated value from the Offchain DB.
        fn clear_version_1(&mut self, key: &[u8]) {
            self.set_offchain_storage(key, None);
        }
        /// Write a key value pair to the Offchain DB database in a buffered fashion.
        fn set_version_1(&mut self, key: &[u8], value: &[u8]) {
            self.set_offchain_storage(key, Some(value));
        }
    }
    trait OffchainIndex {
        /// Remove a key and its associated value from the Offchain DB.
        fn clear_version_1(&mut self, key: &[u8]);
        /// Write a key value pair to the Offchain DB database in a buffered fashion.
        fn set_version_1(&mut self, key: &[u8], value: &[u8]);
    }
    #[cfg(feature = "std")]
    struct ExtOffchainIndexClearVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainIndexClearVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'clear' from interface 'OffchainIndex'",
                        ),
                    );
                    res
                })?;
            let __result__ = clear_version_1(&key);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainIndexClearVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_index_clear_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'clear' from interface 'OffchainIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'clear' from interface 'OffchainIndex'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, key_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainIndexSetVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainIndexSetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'set' from interface 'OffchainIndex'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'set' from interface 'OffchainIndex'",
                        ),
                    );
                    res
                })?;
            let __result__ = set_version_1(&key, &value);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainIndexSetVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_index_set_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'set' from interface 'OffchainIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'set' from interface 'OffchainIndex'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'set' from interface 'OffchainIndex' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'set' from interface 'OffchainIndex'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtOffchainIndexClearVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainIndexSetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainIndexClearVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainIndexClearVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainIndexSetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainIndexSetVersion1::call(
                                                __function_context__,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Deprecated verification context.
///
/// Stores the combined result of all verifications that are done in the same context.
struct VerificationExtDeprecated(pub bool);
impl ::sp_externalities::Extension for VerificationExtDeprecated {
    fn as_mut_any(&mut self) -> &mut dyn std::any::Any {
        self
    }
    fn type_id(&self) -> std::any::TypeId {
        std::any::Any::type_id(self)
    }
}
impl std::ops::Deref for VerificationExtDeprecated {
    type Target = bool;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl std::ops::DerefMut for VerificationExtDeprecated {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl From<bool> for VerificationExtDeprecated {
    fn from(inner: bool) -> Self {
        Self(inner)
    }
}
/// Interface that provides functions to access the offchain functionality.
///
/// These functions are being made available to the runtime and are called by the runtime.
pub mod offchain {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Append header to the request.
    pub fn http_request_add_header(
        request_id: HttpRequestId,
        name: &str,
        value: &str,
    ) -> Result<(), ()> {
        http_request_add_header_version_1(request_id, name, value)
    }
    #[cfg(feature = "std")]
    /// Initiates a http request given HTTP verb and the URL.
    ///
    /// Meta is a future-reserved field containing additional, parity-scale-codec encoded
    /// parameters. Returns the id of newly started request.
    pub fn http_request_start(
        method: &str,
        uri: &str,
        meta: &[u8],
    ) -> Result<HttpRequestId, ()> {
        http_request_start_version_1(method, uri, meta)
    }
    #[cfg(feature = "std")]
    /// Write a chunk of request body.
    ///
    /// Writing an empty chunks finalizes the request.
    /// Passing `None` as deadline blocks forever.
    ///
    /// Returns an error in case deadline is reached or the chunk couldn't be written.
    pub fn http_request_write_body(
        request_id: HttpRequestId,
        chunk: &[u8],
        deadline: Option<Timestamp>,
    ) -> Result<(), HttpError> {
        http_request_write_body_version_1(request_id, chunk, deadline)
    }
    #[cfg(feature = "std")]
    /// Read all response headers.
    ///
    /// Returns a vector of pairs `(HeaderKey, HeaderValue)`.
    /// NOTE: response headers have to be read before response body.
    pub fn http_response_headers(request_id: HttpRequestId) -> Vec<(Vec<u8>, Vec<u8>)> {
        http_response_headers_version_1(request_id)
    }
    #[cfg(feature = "std")]
    /// Read a chunk of body response to given buffer.
    ///
    /// Returns the number of bytes written or an error in case a deadline
    /// is reached or server closed the connection.
    /// If `0` is returned it means that the response has been fully consumed
    /// and the `request_id` is now invalid.
    /// NOTE: this implies that response headers must be read before draining the body.
    /// Passing `None` as a deadline blocks forever.
    pub fn http_response_read_body(
        request_id: HttpRequestId,
        buffer: &mut [u8],
        deadline: Option<Timestamp>,
    ) -> Result<u32, HttpError> {
        http_response_read_body_version_1(request_id, buffer, deadline)
    }
    #[cfg(feature = "std")]
    /// Block and wait for the responses for given requests.
    ///
    /// Returns a vector of request statuses (the len is the same as ids).
    /// Note that if deadline is not provided the method will block indefinitely,
    /// otherwise unready responses will produce `DeadlineReached` status.
    ///
    /// Passing `None` as deadline blocks forever.
    pub fn http_response_wait(
        ids: &[HttpRequestId],
        deadline: Option<Timestamp>,
    ) -> Vec<HttpRequestStatus> {
        http_response_wait_version_1(ids, deadline)
    }
    #[cfg(feature = "std")]
    /// Returns if the local node is a potential validator.
    ///
    /// Even if this function returns `true`, it does not mean that any keys are configured
    /// and that the validator is registered in the chain.
    pub fn is_validator() -> bool {
        is_validator_version_1()
    }
    #[cfg(feature = "std")]
    /// Remove a value from the local storage.
    ///
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    pub fn local_storage_clear(kind: StorageKind, key: &[u8]) {
        local_storage_clear_version_1(kind, key)
    }
    #[cfg(feature = "std")]
    /// Sets a value in the local storage if it matches current value.
    ///
    /// Since multiple offchain workers may be running concurrently, to prevent
    /// data races use CAS to coordinate between them.
    ///
    /// Returns `true` if the value has been set, `false` otherwise.
    ///
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    pub fn local_storage_compare_and_set(
        kind: StorageKind,
        key: &[u8],
        old_value: Option<Vec<u8>>,
        new_value: &[u8],
    ) -> bool {
        local_storage_compare_and_set_version_1(kind, key, old_value, new_value)
    }
    #[cfg(feature = "std")]
    /// Gets a value from the local storage.
    ///
    /// If the value does not exist in the storage `None` will be returned.
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    pub fn local_storage_get(kind: StorageKind, key: &[u8]) -> Option<Vec<u8>> {
        local_storage_get_version_1(kind, key)
    }
    #[cfg(feature = "std")]
    /// Sets a value in the local storage.
    ///
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    pub fn local_storage_set(kind: StorageKind, key: &[u8], value: &[u8]) {
        local_storage_set_version_1(kind, key, value)
    }
    #[cfg(feature = "std")]
    /// Returns information about the local node's network state.
    pub fn network_state() -> Result<OpaqueNetworkState, ()> {
        network_state_version_1()
    }
    #[cfg(feature = "std")]
    /// Returns a random seed.
    ///
    /// This is a truly random, non-deterministic seed generated by host environment.
    /// Obviously fine in the off-chain worker context.
    pub fn random_seed() -> [u8; 32] {
        random_seed_version_1()
    }
    #[cfg(feature = "std")]
    /// Set the authorized nodes and authorized_only flag.
    pub fn set_authorized_nodes(nodes: Vec<OpaquePeerId>, authorized_only: bool) {
        set_authorized_nodes_version_1(nodes, authorized_only)
    }
    #[cfg(feature = "std")]
    /// Pause the execution until `deadline` is reached.
    pub fn sleep_until(deadline: Timestamp) {
        sleep_until_version_1(deadline)
    }
    #[cfg(feature = "std")]
    /// Submit an encoded transaction to the pool.
    ///
    /// The transaction will end up in the pool.
    pub fn submit_transaction(data: Vec<u8>) -> Result<(), ()> {
        submit_transaction_version_1(data)
    }
    #[cfg(feature = "std")]
    /// Returns current UNIX timestamp (in millis)
    pub fn timestamp() -> Timestamp {
        timestamp_version_1()
    }
    #[cfg(feature = "std")]
    /// Append header to the request.
    fn http_request_add_header_version_1(
        request_id: HttpRequestId,
        name: &str,
        value: &str,
    ) -> Result<(), ()> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "http_request_add_header_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::http_request_add_header_version_1(
                        &mut __externalities__,
                        request_id,
                        name,
                        value,
                    ))
                    .expect(
                        "`http_request_add_header_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Initiates a http request given HTTP verb and the URL.
    ///
    /// Meta is a future-reserved field containing additional, parity-scale-codec encoded
    /// parameters. Returns the id of newly started request.
    fn http_request_start_version_1(
        method: &str,
        uri: &str,
        meta: &[u8],
    ) -> Result<HttpRequestId, ()> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "http_request_start_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::http_request_start_version_1(
                        &mut __externalities__,
                        method,
                        uri,
                        meta,
                    ))
                    .expect(
                        "`http_request_start_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Write a chunk of request body.
    ///
    /// Writing an empty chunks finalizes the request.
    /// Passing `None` as deadline blocks forever.
    ///
    /// Returns an error in case deadline is reached or the chunk couldn't be written.
    fn http_request_write_body_version_1(
        request_id: HttpRequestId,
        chunk: &[u8],
        deadline: Option<Timestamp>,
    ) -> Result<(), HttpError> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "http_request_write_body_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::http_request_write_body_version_1(
                        &mut __externalities__,
                        request_id,
                        chunk,
                        deadline,
                    ))
                    .expect(
                        "`http_request_write_body_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Read all response headers.
    ///
    /// Returns a vector of pairs `(HeaderKey, HeaderValue)`.
    /// NOTE: response headers have to be read before response body.
    fn http_response_headers_version_1(
        request_id: HttpRequestId,
    ) -> Vec<(Vec<u8>, Vec<u8>)> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "http_response_headers_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::http_response_headers_version_1(
                        &mut __externalities__,
                        request_id,
                    ))
                    .expect(
                        "`http_response_headers_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Read a chunk of body response to given buffer.
    ///
    /// Returns the number of bytes written or an error in case a deadline
    /// is reached or server closed the connection.
    /// If `0` is returned it means that the response has been fully consumed
    /// and the `request_id` is now invalid.
    /// NOTE: this implies that response headers must be read before draining the body.
    /// Passing `None` as a deadline blocks forever.
    fn http_response_read_body_version_1(
        request_id: HttpRequestId,
        buffer: &mut [u8],
        deadline: Option<Timestamp>,
    ) -> Result<u32, HttpError> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "http_response_read_body_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::http_response_read_body_version_1(
                        &mut __externalities__,
                        request_id,
                        buffer,
                        deadline,
                    ))
                    .expect(
                        "`http_response_read_body_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Block and wait for the responses for given requests.
    ///
    /// Returns a vector of request statuses (the len is the same as ids).
    /// Note that if deadline is not provided the method will block indefinitely,
    /// otherwise unready responses will produce `DeadlineReached` status.
    ///
    /// Passing `None` as deadline blocks forever.
    fn http_response_wait_version_1(
        ids: &[HttpRequestId],
        deadline: Option<Timestamp>,
    ) -> Vec<HttpRequestStatus> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "http_response_wait_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::http_response_wait_version_1(
                        &mut __externalities__,
                        ids,
                        deadline,
                    ))
                    .expect(
                        "`http_response_wait_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns if the local node is a potential validator.
    ///
    /// Even if this function returns `true`, it does not mean that any keys are configured
    /// and that the validator is registered in the chain.
    fn is_validator_version_1() -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "is_validator_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::is_validator_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`is_validator_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Remove a value from the local storage.
    ///
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    fn local_storage_clear_version_1(kind: StorageKind, key: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "local_storage_clear_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::local_storage_clear_version_1(
                        &mut __externalities__,
                        kind,
                        key,
                    ))
                    .expect(
                        "`local_storage_clear_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Sets a value in the local storage if it matches current value.
    ///
    /// Since multiple offchain workers may be running concurrently, to prevent
    /// data races use CAS to coordinate between them.
    ///
    /// Returns `true` if the value has been set, `false` otherwise.
    ///
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    fn local_storage_compare_and_set_version_1(
        kind: StorageKind,
        key: &[u8],
        old_value: Option<Vec<u8>>,
        new_value: &[u8],
    ) -> bool {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "local_storage_compare_and_set_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::local_storage_compare_and_set_version_1(
                        &mut __externalities__,
                        kind,
                        key,
                        old_value,
                        new_value,
                    ))
                    .expect(
                        "`local_storage_compare_and_set_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Gets a value from the local storage.
    ///
    /// If the value does not exist in the storage `None` will be returned.
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    fn local_storage_get_version_1(kind: StorageKind, key: &[u8]) -> Option<Vec<u8>> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "local_storage_get_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::local_storage_get_version_1(
                        &mut __externalities__,
                        kind,
                        key,
                    ))
                    .expect(
                        "`local_storage_get_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Sets a value in the local storage.
    ///
    /// Note this storage is not part of the consensus, it's only accessible by
    /// offchain worker tasks running on the same machine. It IS persisted between runs.
    fn local_storage_set_version_1(kind: StorageKind, key: &[u8], value: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "local_storage_set_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::local_storage_set_version_1(
                        &mut __externalities__,
                        kind,
                        key,
                        value,
                    ))
                    .expect(
                        "`local_storage_set_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns information about the local node's network state.
    fn network_state_version_1() -> Result<OpaqueNetworkState, ()> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "network_state_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::network_state_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`network_state_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns a random seed.
    ///
    /// This is a truly random, non-deterministic seed generated by host environment.
    /// Obviously fine in the off-chain worker context.
    fn random_seed_version_1() -> [u8; 32] {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "random_seed_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::random_seed_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`random_seed_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Set the authorized nodes and authorized_only flag.
    fn set_authorized_nodes_version_1(nodes: Vec<OpaquePeerId>, authorized_only: bool) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "set_authorized_nodes_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::set_authorized_nodes_version_1(
                        &mut __externalities__,
                        nodes,
                        authorized_only,
                    ))
                    .expect(
                        "`set_authorized_nodes_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Pause the execution until `deadline` is reached.
    fn sleep_until_version_1(deadline: Timestamp) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "sleep_until_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::sleep_until_version_1(
                        &mut __externalities__,
                        deadline,
                    ))
                    .expect(
                        "`sleep_until_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Submit an encoded transaction to the pool.
    ///
    /// The transaction will end up in the pool.
    fn submit_transaction_version_1(data: Vec<u8>) -> Result<(), ()> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "submit_transaction_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::submit_transaction_version_1(
                        &mut __externalities__,
                        data,
                    ))
                    .expect(
                        "`submit_transaction_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    /// Returns current UNIX timestamp (in millis)
    fn timestamp_version_1() -> Timestamp {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "timestamp_version_1",
                        "sp_io::offchain",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1332u32),
                        ::core::option::Option::Some("sp_io::offchain"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                proc_macro_runtime_interface::with_externalities(|mut __externalities__| Offchain::timestamp_version_1(
                        &mut __externalities__,
                    ))
                    .expect(
                        "`timestamp_version_1` called outside of an Externalities-provided environment.",
                    )
            })
    }
    #[cfg(feature = "std")]
    impl Offchain for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Append header to the request.
        fn http_request_add_header_version_1(
            &mut self,
            request_id: HttpRequestId,
            name: &str,
            value: &str,
        ) -> Result<(), ()> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "http_request_add_header can be called only in the offchain worker context",
                )
                .http_request_add_header(request_id, name, value)
        }
        /// Initiates a http request given HTTP verb and the URL.
        ///
        /// Meta is a future-reserved field containing additional, parity-scale-codec encoded
        /// parameters. Returns the id of newly started request.
        fn http_request_start_version_1(
            &mut self,
            method: &str,
            uri: &str,
            meta: &[u8],
        ) -> Result<HttpRequestId, ()> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "http_request_start can be called only in the offchain worker context",
                )
                .http_request_start(method, uri, meta)
        }
        /// Write a chunk of request body.
        ///
        /// Writing an empty chunks finalizes the request.
        /// Passing `None` as deadline blocks forever.
        ///
        /// Returns an error in case deadline is reached or the chunk couldn't be written.
        fn http_request_write_body_version_1(
            &mut self,
            request_id: HttpRequestId,
            chunk: &[u8],
            deadline: Option<Timestamp>,
        ) -> Result<(), HttpError> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "http_request_write_body can be called only in the offchain worker context",
                )
                .http_request_write_body(request_id, chunk, deadline)
        }
        /// Read all response headers.
        ///
        /// Returns a vector of pairs `(HeaderKey, HeaderValue)`.
        /// NOTE: response headers have to be read before response body.
        fn http_response_headers_version_1(
            &mut self,
            request_id: HttpRequestId,
        ) -> Vec<(Vec<u8>, Vec<u8>)> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "http_response_headers can be called only in the offchain worker context",
                )
                .http_response_headers(request_id)
        }
        /// Read a chunk of body response to given buffer.
        ///
        /// Returns the number of bytes written or an error in case a deadline
        /// is reached or server closed the connection.
        /// If `0` is returned it means that the response has been fully consumed
        /// and the `request_id` is now invalid.
        /// NOTE: this implies that response headers must be read before draining the body.
        /// Passing `None` as a deadline blocks forever.
        fn http_response_read_body_version_1(
            &mut self,
            request_id: HttpRequestId,
            buffer: &mut [u8],
            deadline: Option<Timestamp>,
        ) -> Result<u32, HttpError> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "http_response_read_body can be called only in the offchain worker context",
                )
                .http_response_read_body(request_id, buffer, deadline)
                .map(|r| r as u32)
        }
        /// Block and wait for the responses for given requests.
        ///
        /// Returns a vector of request statuses (the len is the same as ids).
        /// Note that if deadline is not provided the method will block indefinitely,
        /// otherwise unready responses will produce `DeadlineReached` status.
        ///
        /// Passing `None` as deadline blocks forever.
        fn http_response_wait_version_1(
            &mut self,
            ids: &[HttpRequestId],
            deadline: Option<Timestamp>,
        ) -> Vec<HttpRequestStatus> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "http_response_wait can be called only in the offchain worker context",
                )
                .http_response_wait(ids, deadline)
        }
        /// Returns if the local node is a potential validator.
        ///
        /// Even if this function returns `true`, it does not mean that any keys are configured
        /// and that the validator is registered in the chain.
        fn is_validator_version_1(&mut self) -> bool {
            self.extension::<OffchainWorkerExt>()
                .expect("is_validator can be called only in the offchain worker context")
                .is_validator()
        }
        /// Remove a value from the local storage.
        ///
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_clear_version_1(&mut self, kind: StorageKind, key: &[u8]) {
            self.extension::<OffchainDbExt>()
                .expect(
                    "local_storage_clear can be called only in the offchain call context with
				OffchainDb extension",
                )
                .local_storage_clear(kind, key)
        }
        /// Sets a value in the local storage if it matches current value.
        ///
        /// Since multiple offchain workers may be running concurrently, to prevent
        /// data races use CAS to coordinate between them.
        ///
        /// Returns `true` if the value has been set, `false` otherwise.
        ///
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_compare_and_set_version_1(
            &mut self,
            kind: StorageKind,
            key: &[u8],
            old_value: Option<Vec<u8>>,
            new_value: &[u8],
        ) -> bool {
            self.extension::<OffchainDbExt>()
                .expect(
                    "local_storage_compare_and_set can be called only in the offchain call context
				with OffchainDb extension",
                )
                .local_storage_compare_and_set(
                    kind,
                    key,
                    old_value.as_deref(),
                    new_value,
                )
        }
        /// Gets a value from the local storage.
        ///
        /// If the value does not exist in the storage `None` will be returned.
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_get_version_1(
            &mut self,
            kind: StorageKind,
            key: &[u8],
        ) -> Option<Vec<u8>> {
            self.extension::<OffchainDbExt>()
                .expect(
                    "local_storage_get can be called only in the offchain call context with
				OffchainDb extension",
                )
                .local_storage_get(kind, key)
        }
        /// Sets a value in the local storage.
        ///
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_set_version_1(
            &mut self,
            kind: StorageKind,
            key: &[u8],
            value: &[u8],
        ) {
            self.extension::<OffchainDbExt>()
                .expect(
                    "local_storage_set can be called only in the offchain call context with
				OffchainDb extension",
                )
                .local_storage_set(kind, key, value)
        }
        /// Returns information about the local node's network state.
        fn network_state_version_1(&mut self) -> Result<OpaqueNetworkState, ()> {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "network_state can be called only in the offchain worker context",
                )
                .network_state()
        }
        /// Returns a random seed.
        ///
        /// This is a truly random, non-deterministic seed generated by host environment.
        /// Obviously fine in the off-chain worker context.
        fn random_seed_version_1(&mut self) -> [u8; 32] {
            self.extension::<OffchainWorkerExt>()
                .expect("random_seed can be called only in the offchain worker context")
                .random_seed()
        }
        /// Set the authorized nodes and authorized_only flag.
        fn set_authorized_nodes_version_1(
            &mut self,
            nodes: Vec<OpaquePeerId>,
            authorized_only: bool,
        ) {
            self.extension::<OffchainWorkerExt>()
                .expect(
                    "set_authorized_nodes can be called only in the offchain worker context",
                )
                .set_authorized_nodes(nodes, authorized_only)
        }
        /// Pause the execution until `deadline` is reached.
        fn sleep_until_version_1(&mut self, deadline: Timestamp) {
            self.extension::<OffchainWorkerExt>()
                .expect("sleep_until can be called only in the offchain worker context")
                .sleep_until(deadline)
        }
        /// Submit an encoded transaction to the pool.
        ///
        /// The transaction will end up in the pool.
        fn submit_transaction_version_1(&mut self, data: Vec<u8>) -> Result<(), ()> {
            self.extension::<TransactionPoolExt>()
                .expect(
                    "submit_transaction can be called only in the offchain call context with
				TransactionPool capabilities enabled",
                )
                .submit_transaction(data)
        }
        /// Returns current UNIX timestamp (in millis)
        fn timestamp_version_1(&mut self) -> Timestamp {
            self.extension::<OffchainWorkerExt>()
                .expect("timestamp can be called only in the offchain worker context")
                .timestamp()
        }
    }
    trait Offchain {
        /// Append header to the request.
        fn http_request_add_header_version_1(
            &mut self,
            request_id: HttpRequestId,
            name: &str,
            value: &str,
        ) -> Result<(), ()>;
        /// Initiates a http request given HTTP verb and the URL.
        ///
        /// Meta is a future-reserved field containing additional, parity-scale-codec encoded
        /// parameters. Returns the id of newly started request.
        fn http_request_start_version_1(
            &mut self,
            method: &str,
            uri: &str,
            meta: &[u8],
        ) -> Result<HttpRequestId, ()>;
        /// Write a chunk of request body.
        ///
        /// Writing an empty chunks finalizes the request.
        /// Passing `None` as deadline blocks forever.
        ///
        /// Returns an error in case deadline is reached or the chunk couldn't be written.
        fn http_request_write_body_version_1(
            &mut self,
            request_id: HttpRequestId,
            chunk: &[u8],
            deadline: Option<Timestamp>,
        ) -> Result<(), HttpError>;
        /// Read all response headers.
        ///
        /// Returns a vector of pairs `(HeaderKey, HeaderValue)`.
        /// NOTE: response headers have to be read before response body.
        fn http_response_headers_version_1(
            &mut self,
            request_id: HttpRequestId,
        ) -> Vec<(Vec<u8>, Vec<u8>)>;
        /// Read a chunk of body response to given buffer.
        ///
        /// Returns the number of bytes written or an error in case a deadline
        /// is reached or server closed the connection.
        /// If `0` is returned it means that the response has been fully consumed
        /// and the `request_id` is now invalid.
        /// NOTE: this implies that response headers must be read before draining the body.
        /// Passing `None` as a deadline blocks forever.
        fn http_response_read_body_version_1(
            &mut self,
            request_id: HttpRequestId,
            buffer: &mut [u8],
            deadline: Option<Timestamp>,
        ) -> Result<u32, HttpError>;
        /// Block and wait for the responses for given requests.
        ///
        /// Returns a vector of request statuses (the len is the same as ids).
        /// Note that if deadline is not provided the method will block indefinitely,
        /// otherwise unready responses will produce `DeadlineReached` status.
        ///
        /// Passing `None` as deadline blocks forever.
        fn http_response_wait_version_1(
            &mut self,
            ids: &[HttpRequestId],
            deadline: Option<Timestamp>,
        ) -> Vec<HttpRequestStatus>;
        /// Returns if the local node is a potential validator.
        ///
        /// Even if this function returns `true`, it does not mean that any keys are configured
        /// and that the validator is registered in the chain.
        fn is_validator_version_1(&mut self) -> bool;
        /// Remove a value from the local storage.
        ///
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_clear_version_1(&mut self, kind: StorageKind, key: &[u8]);
        /// Sets a value in the local storage if it matches current value.
        ///
        /// Since multiple offchain workers may be running concurrently, to prevent
        /// data races use CAS to coordinate between them.
        ///
        /// Returns `true` if the value has been set, `false` otherwise.
        ///
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_compare_and_set_version_1(
            &mut self,
            kind: StorageKind,
            key: &[u8],
            old_value: Option<Vec<u8>>,
            new_value: &[u8],
        ) -> bool;
        /// Gets a value from the local storage.
        ///
        /// If the value does not exist in the storage `None` will be returned.
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_get_version_1(
            &mut self,
            kind: StorageKind,
            key: &[u8],
        ) -> Option<Vec<u8>>;
        /// Sets a value in the local storage.
        ///
        /// Note this storage is not part of the consensus, it's only accessible by
        /// offchain worker tasks running on the same machine. It IS persisted between runs.
        fn local_storage_set_version_1(
            &mut self,
            kind: StorageKind,
            key: &[u8],
            value: &[u8],
        );
        /// Returns information about the local node's network state.
        fn network_state_version_1(&mut self) -> Result<OpaqueNetworkState, ()>;
        /// Returns a random seed.
        ///
        /// This is a truly random, non-deterministic seed generated by host environment.
        /// Obviously fine in the off-chain worker context.
        fn random_seed_version_1(&mut self) -> [u8; 32];
        /// Set the authorized nodes and authorized_only flag.
        fn set_authorized_nodes_version_1(
            &mut self,
            nodes: Vec<OpaquePeerId>,
            authorized_only: bool,
        );
        /// Pause the execution until `deadline` is reached.
        fn sleep_until_version_1(&mut self, deadline: Timestamp);
        /// Submit an encoded transaction to the pool.
        ///
        /// The transaction will end up in the pool.
        fn submit_transaction_version_1(&mut self, data: Vec<u8>) -> Result<(), ()>;
        /// Returns current UNIX timestamp (in millis)
        fn timestamp_version_1(&mut self) -> Timestamp;
    }
    #[cfg(feature = "std")]
    struct ExtOffchainHttpRequestAddHeaderVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainHttpRequestAddHeaderVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
            name_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<(), ()> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut request_id = <HttpRequestId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    request_id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_request_add_header' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut name = <str as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    name_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'name' argument through the WASM FFI boundary while executing 'http_request_add_header' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut value = <str as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'http_request_add_header' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = http_request_add_header_version_1(
                request_id,
                &name,
                &value,
            );
            let __result__ = <Result<
                (),
                (),
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainHttpRequestAddHeaderVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_http_request_add_header_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<str as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<str as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        (),
                        (),
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let request_id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'request_id': number of arguments given to 'http_request_add_header' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    request_id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_request_add_header' from interface 'Offchain'"
                        .to_owned()
                })?;
            let name_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'name': number of arguments given to 'http_request_add_header' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let name_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    name_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'name' argument through the WASM FFI boundary while executing 'http_request_add_header' from interface 'Offchain'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'http_request_add_header' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'http_request_add_header' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                request_id_ffi_value,
                name_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainHttpRequestStartVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainHttpRequestStartVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            method_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
            uri_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
            meta_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<HttpRequestId, ()> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut method = <str as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    method_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'method' argument through the WASM FFI boundary while executing 'http_request_start' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut uri = <str as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    uri_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'uri' argument through the WASM FFI boundary while executing 'http_request_start' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut meta = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    meta_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'meta' argument through the WASM FFI boundary while executing 'http_request_start' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = http_request_start_version_1(&method, &uri, &meta);
            let __result__ = <Result<
                HttpRequestId,
                (),
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainHttpRequestStartVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_http_request_start_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<str as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<str as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        HttpRequestId,
                        (),
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let method_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'method': number of arguments given to 'http_request_start' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let method_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    method_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'method' argument through the WASM FFI boundary while executing 'http_request_start' from interface 'Offchain'"
                        .to_owned()
                })?;
            let uri_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'uri': number of arguments given to 'http_request_start' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let uri_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    uri_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'uri' argument through the WASM FFI boundary while executing 'http_request_start' from interface 'Offchain'"
                        .to_owned()
                })?;
            let meta_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'meta': number of arguments given to 'http_request_start' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let meta_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    meta_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'meta' argument through the WASM FFI boundary while executing 'http_request_start' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                method_ffi_value,
                uri_ffi_value,
                meta_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainHttpRequestWriteBodyVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainHttpRequestWriteBodyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
            chunk_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            deadline_ffi_value: <Option<
                Timestamp,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<(), HttpError> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut request_id = <HttpRequestId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    request_id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_request_write_body' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut chunk = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    chunk_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'chunk' argument through the WASM FFI boundary while executing 'http_request_write_body' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut deadline = <Option<
                Timestamp,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    deadline_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'http_request_write_body' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = http_request_write_body_version_1(
                request_id,
                &chunk,
                deadline,
            );
            let __result__ = <Result<
                (),
                HttpError,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainHttpRequestWriteBodyVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_http_request_write_body_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Timestamp,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        (),
                        HttpError,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let request_id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'request_id': number of arguments given to 'http_request_write_body' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    request_id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_request_write_body' from interface 'Offchain'"
                        .to_owned()
                })?;
            let chunk_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'chunk': number of arguments given to 'http_request_write_body' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let chunk_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    chunk_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'chunk' argument through the WASM FFI boundary while executing 'http_request_write_body' from interface 'Offchain'"
                        .to_owned()
                })?;
            let deadline_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'deadline': number of arguments given to 'http_request_write_body' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let deadline_ffi_value: <Option<
                Timestamp,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    deadline_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'http_request_write_body' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                request_id_ffi_value,
                chunk_ffi_value,
                deadline_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainHttpResponseHeadersVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainHttpResponseHeadersVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<(Vec<u8>, Vec<u8>)> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut request_id = <HttpRequestId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    request_id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_response_headers' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = http_response_headers_version_1(request_id);
            let __result__ = <Vec<
                (Vec<u8>, Vec<u8>),
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainHttpResponseHeadersVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_http_response_headers_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        (Vec<u8>, Vec<u8>),
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let request_id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'request_id': number of arguments given to 'http_response_headers' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    request_id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_response_headers' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, request_id_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainHttpResponseReadBodyVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainHttpResponseReadBodyVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
            buffer_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            deadline_ffi_value: <Option<
                Timestamp,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<u32, HttpError> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut request_id = <HttpRequestId as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    request_id_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_response_read_body' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut buffer = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    buffer_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'buffer' argument through the WASM FFI boundary while executing 'http_response_read_body' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut deadline = <Option<
                Timestamp,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    deadline_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'http_response_read_body' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = http_response_read_body_version_1(
                request_id,
                &mut buffer,
                deadline,
            );
            <[u8] as proc_macro_runtime_interface::host::IntoPreallocatedFFIValue>::into_preallocated_ffi_value(
                buffer,
                __function_context__,
                buffer_ffi_value,
            )?;
            let __result__ = <Result<
                u32,
                HttpError,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainHttpResponseReadBodyVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_http_response_read_body_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Timestamp,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        u32,
                        HttpError,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let request_id_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'request_id': number of arguments given to 'http_response_read_body' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    request_id_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'request_id' argument through the WASM FFI boundary while executing 'http_response_read_body' from interface 'Offchain'"
                        .to_owned()
                })?;
            let buffer_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'buffer': number of arguments given to 'http_response_read_body' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let buffer_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    buffer_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'buffer' argument through the WASM FFI boundary while executing 'http_response_read_body' from interface 'Offchain'"
                        .to_owned()
                })?;
            let deadline_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'deadline': number of arguments given to 'http_response_read_body' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let deadline_ffi_value: <Option<
                Timestamp,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    deadline_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'http_response_read_body' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                request_id_ffi_value,
                buffer_ffi_value,
                deadline_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainHttpResponseWaitVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainHttpResponseWaitVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            ids_ffi_value: <[HttpRequestId] as proc_macro_runtime_interface::RIType>::FFIType,
            deadline_ffi_value: <Option<
                Timestamp,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Vec<HttpRequestStatus> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut ids = <[HttpRequestId] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    ids_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'ids' argument through the WASM FFI boundary while executing 'http_response_wait' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut deadline = <Option<
                Timestamp,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    deadline_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'http_response_wait' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = http_response_wait_version_1(&ids, deadline);
            let __result__ = <Vec<
                HttpRequestStatus,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainHttpResponseWaitVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_http_response_wait_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<[HttpRequestId] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Timestamp,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Vec<
                        HttpRequestStatus,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let ids_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'ids': number of arguments given to 'http_response_wait' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let ids_ffi_value: <[HttpRequestId] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    ids_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'ids' argument through the WASM FFI boundary while executing 'http_response_wait' from interface 'Offchain'"
                        .to_owned()
                })?;
            let deadline_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'deadline': number of arguments given to 'http_response_wait' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let deadline_ffi_value: <Option<
                Timestamp,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    deadline_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'http_response_wait' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                ids_ffi_value,
                deadline_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainIsValidatorVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainIsValidatorVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = is_validator_version_1();
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainIsValidatorVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_is_validator_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainLocalStorageClearVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainLocalStorageClearVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut kind = <StorageKind as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    kind_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_clear' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_clear' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = local_storage_clear_version_1(kind, &key);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainLocalStorageClearVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_local_storage_clear_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<StorageKind as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let kind_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'kind': number of arguments given to 'local_storage_clear' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    kind_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_clear' from interface 'Offchain'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'local_storage_clear' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_clear' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                kind_ffi_value,
                key_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainLocalStorageCompareAndSetVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainLocalStorageCompareAndSetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            old_value_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            new_value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut kind = <StorageKind as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    kind_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut old_value = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    old_value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'old_value' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut new_value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    new_value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'new_value' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = local_storage_compare_and_set_version_1(
                kind,
                &key,
                old_value,
                &new_value,
            );
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainLocalStorageCompareAndSetVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_local_storage_compare_and_set_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<StorageKind as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let kind_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'kind': number of arguments given to 'local_storage_compare_and_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    kind_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'local_storage_compare_and_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let old_value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'old_value': number of arguments given to 'local_storage_compare_and_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let old_value_ffi_value: <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    old_value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'old_value' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let new_value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'new_value': number of arguments given to 'local_storage_compare_and_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let new_value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    new_value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'new_value' argument through the WASM FFI boundary while executing 'local_storage_compare_and_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                kind_ffi_value,
                key_ffi_value,
                old_value_ffi_value,
                new_value_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainLocalStorageGetVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainLocalStorageGetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Option<Vec<u8>> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut kind = <StorageKind as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    kind_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_get' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_get' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = local_storage_get_version_1(kind, &key);
            let __result__ = <Option<
                Vec<u8>,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainLocalStorageGetVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_local_storage_get_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<StorageKind as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Option<
                        Vec<u8>,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let kind_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'kind': number of arguments given to 'local_storage_get' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    kind_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_get' from interface 'Offchain'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'local_storage_get' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_get' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                kind_ffi_value,
                key_ffi_value,
            )?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainLocalStorageSetVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainLocalStorageSetVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
            key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
            value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut kind = <StorageKind as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    kind_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut key = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    key_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut value = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    value_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'value' argument through the WASM FFI boundary while executing 'local_storage_set' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = local_storage_set_version_1(kind, &key, &value);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainLocalStorageSetVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_local_storage_set_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<StorageKind as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let kind_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'kind': number of arguments given to 'local_storage_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    kind_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'kind' argument through the WASM FFI boundary while executing 'local_storage_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let key_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'key': number of arguments given to 'local_storage_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    key_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'key' argument through the WASM FFI boundary while executing 'local_storage_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let value_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'value': number of arguments given to 'local_storage_set' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    value_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'value' argument through the WASM FFI boundary while executing 'local_storage_set' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                kind_ffi_value,
                key_ffi_value,
                value_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainNetworkStateVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainNetworkStateVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <Result<
                OpaqueNetworkState,
                (),
            > as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = network_state_version_1();
            let __result__ = <Result<
                OpaqueNetworkState,
                (),
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainNetworkStateVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_network_state_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<Result<
                        OpaqueNetworkState,
                        (),
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainRandomSeedVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainRandomSeedVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = random_seed_version_1();
            let __result__ = <[u8; 32] as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainRandomSeedVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_random_seed_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainSetAuthorizedNodesVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainSetAuthorizedNodesVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            nodes_ffi_value: <Vec<
                OpaquePeerId,
            > as proc_macro_runtime_interface::RIType>::FFIType,
            authorized_only_ffi_value: <bool as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut nodes = <Vec<
                OpaquePeerId,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    nodes_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'nodes' argument through the WASM FFI boundary while executing 'set_authorized_nodes' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let mut authorized_only = <bool as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    authorized_only_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'authorized_only' argument through the WASM FFI boundary while executing 'set_authorized_nodes' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = set_authorized_nodes_version_1(nodes, authorized_only);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainSetAuthorizedNodesVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_set_authorized_nodes_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            OpaquePeerId,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let nodes_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'nodes': number of arguments given to 'set_authorized_nodes' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let nodes_ffi_value: <Vec<
                OpaquePeerId,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    nodes_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'nodes' argument through the WASM FFI boundary while executing 'set_authorized_nodes' from interface 'Offchain'"
                        .to_owned()
                })?;
            let authorized_only_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'authorized_only': number of arguments given to 'set_authorized_nodes' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let authorized_only_ffi_value: <bool as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    authorized_only_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'authorized_only' argument through the WASM FFI boundary while executing 'set_authorized_nodes' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                nodes_ffi_value,
                authorized_only_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainSleepUntilVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainSleepUntilVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            deadline_ffi_value: <Timestamp as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut deadline = <Timestamp as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    deadline_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'sleep_until' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = sleep_until_version_1(deadline);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainSleepUntilVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_sleep_until_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Timestamp as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let deadline_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'deadline': number of arguments given to 'sleep_until' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let deadline_ffi_value: <Timestamp as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    deadline_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'deadline' argument through the WASM FFI boundary while executing 'sleep_until' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, deadline_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainSubmitTransactionVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainSubmitTransactionVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            data_ffi_value: <Vec<u8> as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Result<(), ()> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut data = <Vec<
                u8,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    data_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'data' argument through the WASM FFI boundary while executing 'submit_transaction' from interface 'Offchain'",
                        ),
                    );
                    res
                })?;
            let __result__ = submit_transaction_version_1(data);
            let __result__ = <Result<
                (),
                (),
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainSubmitTransactionVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_submit_transaction_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Vec<
                            u8,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Result<
                        (),
                        (),
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let data_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'data': number of arguments given to 'submit_transaction' from interface 'Offchain' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let data_ffi_value: <Vec<
                u8,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    data_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'data' argument through the WASM FFI boundary while executing 'submit_transaction' from interface 'Offchain'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, data_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtOffchainTimestampVersion1;
    #[cfg(feature = "std")]
    impl ExtOffchainTimestampVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <Timestamp as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = timestamp_version_1();
            let __result__ = <Timestamp as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtOffchainTimestampVersion1 {
        fn name(&self) -> &str {
            "ext_offchain_timestamp_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<Timestamp as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtOffchainHttpRequestAddHeaderVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainHttpRequestStartVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainHttpRequestWriteBodyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainHttpResponseHeadersVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainHttpResponseReadBodyVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainHttpResponseWaitVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainIsValidatorVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainLocalStorageClearVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainLocalStorageCompareAndSetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainLocalStorageGetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainLocalStorageSetVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainNetworkStateVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainRandomSeedVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainSetAuthorizedNodesVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainSleepUntilVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainSubmitTransactionVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtOffchainTimestampVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainHttpRequestAddHeaderVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
                        name_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            (),
                            (),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainHttpRequestAddHeaderVersion1::call(
                                                __function_context__,
                                                request_id_ffi_value,
                                                name_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainHttpRequestStartVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        method_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
                        uri_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
                        meta_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            HttpRequestId,
                            (),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainHttpRequestStartVersion1::call(
                                                __function_context__,
                                                method_ffi_value,
                                                uri_ffi_value,
                                                meta_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainHttpRequestWriteBodyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
                        chunk_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        deadline_ffi_value: <Option<
                            Timestamp,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            (),
                            HttpError,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainHttpRequestWriteBodyVersion1::call(
                                                __function_context__,
                                                request_id_ffi_value,
                                                chunk_ffi_value,
                                                deadline_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainHttpResponseHeadersVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<
                            (Vec<u8>, Vec<u8>),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainHttpResponseHeadersVersion1::call(
                                                __function_context__,
                                                request_id_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainHttpResponseReadBodyVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        request_id_ffi_value: <HttpRequestId as proc_macro_runtime_interface::RIType>::FFIType,
                        buffer_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        deadline_ffi_value: <Option<
                            Timestamp,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            u32,
                            HttpError,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainHttpResponseReadBodyVersion1::call(
                                                __function_context__,
                                                request_id_ffi_value,
                                                buffer_ffi_value,
                                                deadline_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainHttpResponseWaitVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        ids_ffi_value: <[HttpRequestId] as proc_macro_runtime_interface::RIType>::FFIType,
                        deadline_ffi_value: <Option<
                            Timestamp,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Vec<
                            HttpRequestStatus,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainHttpResponseWaitVersion1::call(
                                                __function_context__,
                                                ids_ffi_value,
                                                deadline_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainIsValidatorVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainIsValidatorVersion1::call(__function_context__)
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainLocalStorageClearVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainLocalStorageClearVersion1::call(
                                                __function_context__,
                                                kind_ffi_value,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainLocalStorageCompareAndSetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        old_value_ffi_value: <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        new_value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainLocalStorageCompareAndSetVersion1::call(
                                                __function_context__,
                                                kind_ffi_value,
                                                key_ffi_value,
                                                old_value_ffi_value,
                                                new_value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainLocalStorageGetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Option<
                            Vec<u8>,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainLocalStorageGetVersion1::call(
                                                __function_context__,
                                                kind_ffi_value,
                                                key_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainLocalStorageSetVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        kind_ffi_value: <StorageKind as proc_macro_runtime_interface::RIType>::FFIType,
                        key_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                        value_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainLocalStorageSetVersion1::call(
                                                __function_context__,
                                                kind_ffi_value,
                                                key_ffi_value,
                                                value_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainNetworkStateVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <Result<
                            OpaqueNetworkState,
                            (),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainNetworkStateVersion1::call(__function_context__)
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainRandomSeedVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <[u8; 32] as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainRandomSeedVersion1::call(__function_context__)
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainSetAuthorizedNodesVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        nodes_ffi_value: <Vec<
                            OpaquePeerId,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        authorized_only_ffi_value: <bool as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainSetAuthorizedNodesVersion1::call(
                                                __function_context__,
                                                nodes_ffi_value,
                                                authorized_only_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainSleepUntilVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        deadline_ffi_value: <Timestamp as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainSleepUntilVersion1::call(
                                                __function_context__,
                                                deadline_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainSubmitTransactionVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        data_ffi_value: <Vec<
                            u8,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Result<
                            (),
                            (),
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainSubmitTransactionVersion1::call(
                                                __function_context__,
                                                data_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtOffchainTimestampVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <Timestamp as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtOffchainTimestampVersion1::call(__function_context__)
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Wasm only interface that provides functions for calling into the allocator.
pub mod allocator {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Free the given pointer.
    fn free_version_1(
        ptr: Pointer<u8>,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "free_version_1",
                        "sp_io::allocator",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1551u32),
                        ::core::option::Option::Some("sp_io::allocator"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| { Allocator::free_version_1(&mut __function_context__, ptr) })
    }
    #[cfg(feature = "std")]
    /// Malloc the given number of bytes and return the pointer to the allocated memory location.
    fn malloc_version_1(
        size: u32,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) -> Pointer<u8> {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "malloc_version_1",
                        "sp_io::allocator",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1551u32),
                        ::core::option::Option::Some("sp_io::allocator"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                Allocator::malloc_version_1(&mut __function_context__, size)
            })
    }
    #[cfg(feature = "std")]
    impl Allocator
    for &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext {
        /// Free the given pointer.
        fn free_version_1(&mut self, ptr: Pointer<u8>) {
            self.deallocate_memory(ptr).expect("Failed to deallocate memory")
        }
        /// Malloc the given number of bytes and return the pointer to the allocated memory location.
        fn malloc_version_1(&mut self, size: u32) -> Pointer<u8> {
            self.allocate_memory(size).expect("Failed to allocate memory")
        }
    }
    trait Allocator {
        /// Free the given pointer.
        fn free_version_1(&mut self, ptr: Pointer<u8>);
        /// Malloc the given number of bytes and return the pointer to the allocated memory location.
        fn malloc_version_1(&mut self, size: u32) -> Pointer<u8>;
    }
    #[cfg(feature = "std")]
    struct ExtAllocatorFreeVersion1;
    #[cfg(feature = "std")]
    impl ExtAllocatorFreeVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            ptr_ffi_value: <Pointer<u8> as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut ptr = <Pointer<
                u8,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    ptr_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'ptr' argument through the WASM FFI boundary while executing 'free' from interface 'Allocator'",
                        ),
                    );
                    res
                })?;
            let __result__ = free_version_1(ptr, __function_context__);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtAllocatorFreeVersion1 {
        fn name(&self) -> &str {
            "ext_allocator_free_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Pointer<
                            u8,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let ptr_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'ptr': number of arguments given to 'free' from interface 'Allocator' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let ptr_ffi_value: <Pointer<
                u8,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    ptr_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'ptr' argument through the WASM FFI boundary while executing 'free' from interface 'Allocator'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, ptr_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtAllocatorMallocVersion1;
    #[cfg(feature = "std")]
    impl ExtAllocatorMallocVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            size_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <Pointer<u8> as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut size = <u32 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    size_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'size' argument through the WASM FFI boundary while executing 'malloc' from interface 'Allocator'",
                        ),
                    );
                    res
                })?;
            let __result__ = malloc_version_1(size, __function_context__);
            let __result__ = <Pointer<
                u8,
            > as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtAllocatorMallocVersion1 {
        fn name(&self) -> &str {
            "ext_allocator_malloc_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<u32 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<Pointer<
                        u8,
                    > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let size_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'size': number of arguments given to 'malloc' from interface 'Allocator' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let size_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    size_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'size' argument through the WASM FFI boundary while executing 'malloc' from interface 'Allocator'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, size_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtAllocatorFreeVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtAllocatorMallocVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtAllocatorFreeVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        ptr_ffi_value: <Pointer<
                            u8,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtAllocatorFreeVersion1::call(
                                                __function_context__,
                                                ptr_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtAllocatorMallocVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        size_ffi_value: <u32 as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <Pointer<u8> as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtAllocatorMallocVersion1::call(
                                                __function_context__,
                                                size_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// WASM-only interface which allows for aborting the execution in case
/// of an unrecoverable error.
pub mod panic_handler {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Aborts the current execution with the given error message.
    fn abort_on_panic_version_1(
        message: &str,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "abort_on_panic_version_1",
                        "sp_io::panic_handler",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1566u32),
                        ::core::option::Option::Some("sp_io::panic_handler"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                PanicHandler::abort_on_panic_version_1(
                    &mut __function_context__,
                    message,
                )
            })
    }
    #[cfg(feature = "std")]
    impl PanicHandler
    for &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext {
        /// Aborts the current execution with the given error message.
        fn abort_on_panic_version_1(&mut self, message: &str) {
            self.register_panic_error_message(message);
        }
    }
    trait PanicHandler {
        /// Aborts the current execution with the given error message.
        fn abort_on_panic_version_1(&mut self, message: &str);
    }
    #[cfg(feature = "std")]
    struct ExtPanicHandlerAbortOnPanicVersion1;
    #[cfg(feature = "std")]
    impl ExtPanicHandlerAbortOnPanicVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            message_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut message = <str as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    message_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'message' argument through the WASM FFI boundary while executing 'abort_on_panic' from interface 'PanicHandler'",
                        ),
                    );
                    res
                })?;
            let __result__ = abort_on_panic_version_1(&message, __function_context__);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtPanicHandlerAbortOnPanicVersion1 {
        fn name(&self) -> &str {
            "ext_panic_handler_abort_on_panic_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<str as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let message_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'message': number of arguments given to 'abort_on_panic' from interface 'PanicHandler' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let message_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    message_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'message' argument through the WASM FFI boundary while executing 'abort_on_panic' from interface 'PanicHandler'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, message_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtPanicHandlerAbortOnPanicVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtPanicHandlerAbortOnPanicVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        message_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtPanicHandlerAbortOnPanicVersion1::call(
                                                __function_context__,
                                                message_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Interface that provides functions for logging from within the runtime.
pub mod logging {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Request to print a log message on the host.
    ///
    /// Note that this will be only displayed if the host is enabled to display log messages with
    /// given level and target.
    ///
    /// Instead of using directly, prefer setting up `RuntimeLogger` and using `log` macros.
    pub fn log(level: LogLevel, target: &str, message: &[u8]) {
        log_version_1(level, target, message)
    }
    #[cfg(feature = "std")]
    /// Returns the max log level used by the host.
    pub fn max_level() -> LogLevelFilter {
        max_level_version_1()
    }
    #[cfg(feature = "std")]
    /// Request to print a log message on the host.
    ///
    /// Note that this will be only displayed if the host is enabled to display log messages with
    /// given level and target.
    ///
    /// Instead of using directly, prefer setting up `RuntimeLogger` and using `log` macros.
    fn log_version_1(level: LogLevel, target: &str, message: &[u8]) {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "log_version_1",
                        "sp_io::logging",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1576u32),
                        ::core::option::Option::Some("sp_io::logging"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Logging>::log_version_1(
                    level,
                    target,
                    message,
                )
            })
    }
    #[cfg(feature = "std")]
    /// Returns the max log level used by the host.
    fn max_level_version_1() -> LogLevelFilter {
        {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "max_level_version_1",
                        "sp_io::logging",
                        ::tracing::Level::TRACE,
                        ::core::option::Option::Some(
                            "substrate/primitives/io/src/lib.rs",
                        ),
                        ::core::option::Option::Some(1576u32),
                        ::core::option::Option::Some("sp_io::logging"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                {};
                span
            }
        }
            .in_scope(|| {
                <&mut dyn proc_macro_runtime_interface::Externalities as Logging>::max_level_version_1()
            })
    }
    #[cfg(feature = "std")]
    impl Logging for &mut dyn proc_macro_runtime_interface::Externalities {
        /// Request to print a log message on the host.
        ///
        /// Note that this will be only displayed if the host is enabled to display log messages with
        /// given level and target.
        ///
        /// Instead of using directly, prefer setting up `RuntimeLogger` and using `log` macros.
        fn log_version_1(level: LogLevel, target: &str, message: &[u8]) {
            if let Ok(message) = std::str::from_utf8(message) {
                {
                    let lvl = log::Level::from(level);
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("{0}", message),
                            lvl,
                            &(
                                target,
                                "sp_io::logging",
                                "substrate/primitives/io/src/lib.rs",
                            ),
                            1586u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
            }
        }
        /// Returns the max log level used by the host.
        fn max_level_version_1() -> LogLevelFilter {
            log::max_level().into()
        }
    }
    trait Logging {
        /// Request to print a log message on the host.
        ///
        /// Note that this will be only displayed if the host is enabled to display log messages with
        /// given level and target.
        ///
        /// Instead of using directly, prefer setting up `RuntimeLogger` and using `log` macros.
        fn log_version_1(level: LogLevel, target: &str, message: &[u8]);
        /// Returns the max log level used by the host.
        fn max_level_version_1() -> LogLevelFilter;
    }
    #[cfg(feature = "std")]
    struct ExtLoggingLogVersion1;
    #[cfg(feature = "std")]
    impl ExtLoggingLogVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            level_ffi_value: <LogLevel as proc_macro_runtime_interface::RIType>::FFIType,
            target_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
            message_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut level = <LogLevel as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    level_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'level' argument through the WASM FFI boundary while executing 'log' from interface 'Logging'",
                        ),
                    );
                    res
                })?;
            let mut target = <str as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    target_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'target' argument through the WASM FFI boundary while executing 'log' from interface 'Logging'",
                        ),
                    );
                    res
                })?;
            let mut message = <[u8] as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    message_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'message' argument through the WASM FFI boundary while executing 'log' from interface 'Logging'",
                        ),
                    );
                    res
                })?;
            let __result__ = log_version_1(level, &target, &message);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtLoggingLogVersion1 {
        fn name(&self) -> &str {
            "ext_logging_log_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<LogLevel as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<str as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                        <<[u8] as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let level_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'level': number of arguments given to 'log' from interface 'Logging' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let level_ffi_value: <LogLevel as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    level_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'level' argument through the WASM FFI boundary while executing 'log' from interface 'Logging'"
                        .to_owned()
                })?;
            let target_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'target': number of arguments given to 'log' from interface 'Logging' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let target_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    target_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'target' argument through the WASM FFI boundary while executing 'log' from interface 'Logging'"
                        .to_owned()
                })?;
            let message_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'message': number of arguments given to 'log' from interface 'Logging' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let message_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    message_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'message' argument through the WASM FFI boundary while executing 'log' from interface 'Logging'"
                        .to_owned()
                })?;
            let __result__ = Self::call(
                __function_context__,
                level_ffi_value,
                target_ffi_value,
                message_ffi_value,
            )?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtLoggingMaxLevelVersion1;
    #[cfg(feature = "std")]
    impl ExtLoggingMaxLevelVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
        ) -> std::result::Result<
            <LogLevelFilter as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let __result__ = max_level_version_1();
            let __result__ = <LogLevelFilter as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtLoggingMaxLevelVersion1 {
        fn name(&self) -> &str {
            "ext_logging_max_level_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(&[][..]),
                return_value: Some(
                    <<LogLevelFilter as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let __result__ = Self::call(__function_context__)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtLoggingLogVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtLoggingMaxLevelVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtLoggingLogVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        level_ffi_value: <LogLevel as proc_macro_runtime_interface::RIType>::FFIType,
                        target_ffi_value: <str as proc_macro_runtime_interface::RIType>::FFIType,
                        message_ffi_value: <[u8] as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtLoggingLogVersion1::call(
                                                __function_context__,
                                                level_ffi_value,
                                                target_ffi_value,
                                                message_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtLoggingMaxLevelVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                    | -> std::result::Result<
                        <LogLevelFilter as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtLoggingMaxLevelVersion1::call(__function_context__)
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
/// Crossing is a helper wrapping any Encode-Decodeable type
/// for transferring over the wasm barrier.
pub struct Crossing<T: Encode + Decode>(T);
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Encode + Decode> ::codec::Encode for Crossing<T>
    where
        T: ::codec::Encode,
        T: ::codec::Encode,
    {
        fn size_hint(&self) -> usize {
            ::codec::Encode::size_hint(&&self.0)
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
        }
        fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
            ::codec::Encode::encode(&&self.0)
        }
        fn using_encoded<R, F: ::core::ops::FnOnce(&[::core::primitive::u8]) -> R>(
            &self,
            f: F,
        ) -> R {
            ::codec::Encode::using_encoded(&&self.0, f)
        }
    }
    #[automatically_derived]
    impl<T: Encode + Decode> ::codec::EncodeLike for Crossing<T>
    where
        T: ::codec::Encode,
        T: ::codec::Encode,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Encode + Decode> ::codec::Decode for Crossing<T>
    where
        T: ::codec::Decode,
        T: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(
                Crossing::<
                    T,
                >({
                    let __codec_res_edqy = <T as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `Crossing.0`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                }),
            )
        }
    }
};
impl<T: Encode + Decode> PassBy for Crossing<T> {
    type PassBy = sp_runtime_interface::pass_by::Codec<Self>;
}
impl<T: Encode + Decode> Crossing<T> {
    /// Convert into the inner type
    pub fn into_inner(self) -> T {
        self.0
    }
}
impl<T> core::default::Default for Crossing<T>
where
    T: core::default::Default + Encode + Decode,
{
    fn default() -> Self {
        Self(Default::default())
    }
}
/// Interface to provide tracing facilities for wasm. Modelled after tokios `tracing`-crate
/// interfaces. See `sp-tracing` for more information.
pub mod wasm_tracing {
    use super::*;
    #[doc(hidden)]
    extern crate sp_runtime_interface as proc_macro_runtime_interface;
    #[cfg(feature = "std")]
    /// Whether the span described in `WasmMetadata` should be traced wasm-side
    /// On the host converts into a static Metadata and checks against the global `tracing`
    /// dispatcher.
    ///
    /// When returning false the calling code should skip any tracing-related execution. In general
    /// within the same block execution this is not expected to change and it doesn't have to be
    /// checked more than once per metadata. This exists for optimisation purposes but is still not
    /// cheap as it will jump the wasm-native-barrier every time it is called. So an implementation
    /// might chose to cache the result for the execution of the entire block.
    fn enabled_version_1(
        metadata: Crossing<sp_tracing::WasmMetadata>,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) -> bool {
        WasmTracing::enabled_version_1(&mut __function_context__, metadata)
    }
    #[cfg(feature = "std")]
    /// Open a new span with the given attributes. Return the u64 Id of the span.
    ///
    /// On the native side this goes through the default `tracing` dispatcher to register the span
    /// and then calls `clone_span` with the ID to signal that we are keeping it around on the wasm-
    /// side even after the local span is dropped. The resulting ID is then handed over to the wasm-
    /// side.
    fn enter_span_version_1(
        span: Crossing<sp_tracing::WasmEntryAttributes>,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) -> u64 {
        WasmTracing::enter_span_version_1(&mut __function_context__, span)
    }
    #[cfg(feature = "std")]
    /// Emit the given event to the global tracer on the native side
    fn event_version_1(
        event: Crossing<sp_tracing::WasmEntryAttributes>,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) {
        WasmTracing::event_version_1(&mut __function_context__, event)
    }
    #[cfg(feature = "std")]
    /// Signal that a given span-id has been exited. On native, this directly
    /// proxies the span to the global dispatcher.
    fn exit_version_1(
        span: u64,
        mut __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
    ) {
        WasmTracing::exit_version_1(&mut __function_context__, span)
    }
    #[cfg(feature = "std")]
    impl WasmTracing
    for &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext {
        /// Whether the span described in `WasmMetadata` should be traced wasm-side
        /// On the host converts into a static Metadata and checks against the global `tracing`
        /// dispatcher.
        ///
        /// When returning false the calling code should skip any tracing-related execution. In general
        /// within the same block execution this is not expected to change and it doesn't have to be
        /// checked more than once per metadata. This exists for optimisation purposes but is still not
        /// cheap as it will jump the wasm-native-barrier every time it is called. So an implementation
        /// might chose to cache the result for the execution of the entire block.
        fn enabled_version_1(
            &mut self,
            metadata: Crossing<sp_tracing::WasmMetadata>,
        ) -> bool {
            let metadata: &tracing_core::metadata::Metadata<'static> = (&metadata
                .into_inner())
                .into();
            tracing::dispatcher::get_default(|d| d.enabled(metadata))
        }
        /// Open a new span with the given attributes. Return the u64 Id of the span.
        ///
        /// On the native side this goes through the default `tracing` dispatcher to register the span
        /// and then calls `clone_span` with the ID to signal that we are keeping it around on the wasm-
        /// side even after the local span is dropped. The resulting ID is then handed over to the wasm-
        /// side.
        fn enter_span_version_1(
            &mut self,
            span: Crossing<sp_tracing::WasmEntryAttributes>,
        ) -> u64 {
            let span: tracing::Span = span.into_inner().into();
            match span.id() {
                Some(id) => {
                    tracing::dispatcher::get_default(|d| {
                        let final_id = d.clone_span(&id);
                        d.enter(&final_id);
                        final_id.into_u64()
                    })
                }
                _ => 0,
            }
        }
        /// Emit the given event to the global tracer on the native side
        fn event_version_1(&mut self, event: Crossing<sp_tracing::WasmEntryAttributes>) {
            event.into_inner().emit();
        }
        /// Signal that a given span-id has been exited. On native, this directly
        /// proxies the span to the global dispatcher.
        fn exit_version_1(&mut self, span: u64) {
            tracing::dispatcher::get_default(|d| {
                let id = tracing_core::span::Id::from_u64(span);
                d.exit(&id);
            });
        }
    }
    trait WasmTracing {
        /// Whether the span described in `WasmMetadata` should be traced wasm-side
        /// On the host converts into a static Metadata and checks against the global `tracing`
        /// dispatcher.
        ///
        /// When returning false the calling code should skip any tracing-related execution. In general
        /// within the same block execution this is not expected to change and it doesn't have to be
        /// checked more than once per metadata. This exists for optimisation purposes but is still not
        /// cheap as it will jump the wasm-native-barrier every time it is called. So an implementation
        /// might chose to cache the result for the execution of the entire block.
        fn enabled_version_1(
            &mut self,
            metadata: Crossing<sp_tracing::WasmMetadata>,
        ) -> bool;
        /// Open a new span with the given attributes. Return the u64 Id of the span.
        ///
        /// On the native side this goes through the default `tracing` dispatcher to register the span
        /// and then calls `clone_span` with the ID to signal that we are keeping it around on the wasm-
        /// side even after the local span is dropped. The resulting ID is then handed over to the wasm-
        /// side.
        fn enter_span_version_1(
            &mut self,
            span: Crossing<sp_tracing::WasmEntryAttributes>,
        ) -> u64;
        /// Emit the given event to the global tracer on the native side
        fn event_version_1(&mut self, event: Crossing<sp_tracing::WasmEntryAttributes>);
        /// Signal that a given span-id has been exited. On native, this directly
        /// proxies the span to the global dispatcher.
        fn exit_version_1(&mut self, span: u64);
    }
    #[cfg(feature = "std")]
    struct ExtWasmTracingEnabledVersion1;
    #[cfg(feature = "std")]
    impl ExtWasmTracingEnabledVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            metadata_ffi_value: <Crossing<
                sp_tracing::WasmMetadata,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <bool as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut metadata = <Crossing<
                sp_tracing::WasmMetadata,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    metadata_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'metadata' argument through the WASM FFI boundary while executing 'enabled' from interface 'WasmTracing'",
                        ),
                    );
                    res
                })?;
            let __result__ = enabled_version_1(metadata, __function_context__);
            let __result__ = <bool as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtWasmTracingEnabledVersion1 {
        fn name(&self) -> &str {
            "ext_wasm_tracing_enabled_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Crossing<
                            sp_tracing::WasmMetadata,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<bool as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let metadata_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'metadata': number of arguments given to 'enabled' from interface 'WasmTracing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let metadata_ffi_value: <Crossing<
                sp_tracing::WasmMetadata,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    metadata_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'metadata' argument through the WASM FFI boundary while executing 'enabled' from interface 'WasmTracing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, metadata_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtWasmTracingEnterSpanVersion1;
    #[cfg(feature = "std")]
    impl ExtWasmTracingEnterSpanVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            span_ffi_value: <Crossing<
                sp_tracing::WasmEntryAttributes,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<
            <u64 as proc_macro_runtime_interface::RIType>::FFIType,
            String,
        > {
            let mut span = <Crossing<
                sp_tracing::WasmEntryAttributes,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    span_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'span' argument through the WASM FFI boundary while executing 'enter_span' from interface 'WasmTracing'",
                        ),
                    );
                    res
                })?;
            let __result__ = enter_span_version_1(span, __function_context__);
            let __result__ = <u64 as proc_macro_runtime_interface::host::IntoFFIValue>::into_ffi_value(
                __result__,
                __function_context__,
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtWasmTracingEnterSpanVersion1 {
        fn name(&self) -> &str {
            "ext_wasm_tracing_enter_span_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Crossing<
                            sp_tracing::WasmEntryAttributes,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: Some(
                    <<u64 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                ),
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let span_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'span': number of arguments given to 'enter_span' from interface 'WasmTracing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let span_ffi_value: <Crossing<
                sp_tracing::WasmEntryAttributes,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    span_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'span' argument through the WASM FFI boundary while executing 'enter_span' from interface 'WasmTracing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, span_ffi_value)?;
            let __result__ = Ok(
                Some(
                    proc_macro_runtime_interface::sp_wasm_interface::IntoValue::into_value(
                        __result__,
                    ),
                ),
            );
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtWasmTracingEventVersion1;
    #[cfg(feature = "std")]
    impl ExtWasmTracingEventVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            event_ffi_value: <Crossing<
                sp_tracing::WasmEntryAttributes,
            > as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut event = <Crossing<
                sp_tracing::WasmEntryAttributes,
            > as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    event_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'event' argument through the WASM FFI boundary while executing 'event' from interface 'WasmTracing'",
                        ),
                    );
                    res
                })?;
            let __result__ = event_version_1(event, __function_context__);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtWasmTracingEventVersion1 {
        fn name(&self) -> &str {
            "ext_wasm_tracing_event_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<Crossing<
                            sp_tracing::WasmEntryAttributes,
                        > as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let event_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'event': number of arguments given to 'event' from interface 'WasmTracing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let event_ffi_value: <Crossing<
                sp_tracing::WasmEntryAttributes,
            > as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    event_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'event' argument through the WASM FFI boundary while executing 'event' from interface 'WasmTracing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, event_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    #[cfg(feature = "std")]
    struct ExtWasmTracingExitVersion1;
    #[cfg(feature = "std")]
    impl ExtWasmTracingExitVersion1 {
        fn call(
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            span_ffi_value: <u64 as proc_macro_runtime_interface::RIType>::FFIType,
        ) -> std::result::Result<(), String> {
            let mut span = <u64 as proc_macro_runtime_interface::host::FromFFIValue>::from_ffi_value(
                    __function_context__,
                    span_ffi_value,
                )
                .map_err(|err| {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}: {1}",
                            err,
                            "could not marshal the 'span' argument through the WASM FFI boundary while executing 'exit' from interface 'WasmTracing'",
                        ),
                    );
                    res
                })?;
            let __result__ = exit_version_1(span, __function_context__);
            let __result__ = Ok(__result__);
            __result__
        }
    }
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::Function
    for ExtWasmTracingExitVersion1 {
        fn name(&self) -> &str {
            "ext_wasm_tracing_exit_version_1"
        }
        fn signature(
            &self,
        ) -> proc_macro_runtime_interface::sp_wasm_interface::Signature {
            proc_macro_runtime_interface::sp_wasm_interface::Signature {
                args: std::borrow::Cow::Borrowed(
                    &[
                        <<u64 as proc_macro_runtime_interface::RIType>::FFIType as proc_macro_runtime_interface::sp_wasm_interface::IntoValue>::VALUE_TYPE,
                    ][..],
                ),
                return_value: None,
            }
        }
        fn execute(
            &self,
            __function_context__: &mut dyn proc_macro_runtime_interface::sp_wasm_interface::FunctionContext,
            args: &mut dyn Iterator<
                Item = proc_macro_runtime_interface::sp_wasm_interface::Value,
            >,
        ) -> std::result::Result<
            Option<proc_macro_runtime_interface::sp_wasm_interface::Value>,
            String,
        > {
            let span_ffi_value = args
                .next()
                .ok_or_else(|| {
                    "missing argument 'span': number of arguments given to 'exit' from interface 'WasmTracing' does not match the expected number of arguments"
                        .to_owned()
                })?;
            let span_ffi_value: <u64 as proc_macro_runtime_interface::RIType>::FFIType = proc_macro_runtime_interface::sp_wasm_interface::TryFromValue::try_from_value(
                    span_ffi_value,
                )
                .ok_or_else(|| {
                    "could not marshal the 'span' argument through the WASM FFI boundary while executing 'exit' from interface 'WasmTracing'"
                        .to_owned()
                })?;
            let __result__ = Self::call(__function_context__, span_ffi_value)?;
            let __result__ = Ok(None);
            __result__
        }
    }
    /// Provides implementations for the extern host functions.
    #[cfg(feature = "std")]
    pub struct HostFunctions;
    #[cfg(feature = "std")]
    impl proc_macro_runtime_interface::sp_wasm_interface::HostFunctions
    for HostFunctions {
        fn host_functions() -> Vec<
            &'static dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
        > {
            let mut host_functions_list = Vec::new();
            host_functions_list
                .push(
                    &ExtWasmTracingEnabledVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtWasmTracingEnterSpanVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtWasmTracingEventVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
                .push(
                    &ExtWasmTracingExitVersion1
                        as &dyn proc_macro_runtime_interface::sp_wasm_interface::Function,
                );
            host_functions_list
        }
        fn register_static<T>(registry: &mut T) -> core::result::Result<(), T::Error>
        where
            T: proc_macro_runtime_interface::sp_wasm_interface::HostFunctionRegistry,
        {
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtWasmTracingEnabledVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        metadata_ffi_value: <Crossing<
                            sp_tracing::WasmMetadata,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <bool as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtWasmTracingEnabledVersion1::call(
                                                __function_context__,
                                                metadata_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtWasmTracingEnterSpanVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        span_ffi_value: <Crossing<
                            sp_tracing::WasmEntryAttributes,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        <u64 as proc_macro_runtime_interface::RIType>::FFIType,
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtWasmTracingEnterSpanVersion1::call(
                                                __function_context__,
                                                span_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtWasmTracingEventVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        event_ffi_value: <Crossing<
                            sp_tracing::WasmEntryAttributes,
                        > as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtWasmTracingEventVersion1::call(
                                                __function_context__,
                                                event_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            registry
                .register_static(
                    proc_macro_runtime_interface::sp_wasm_interface::Function::name(
                        &ExtWasmTracingExitVersion1,
                    ),
                    |
                        mut caller: proc_macro_runtime_interface::sp_wasm_interface::wasmtime::Caller<
                            T::State,
                        >,
                        span_ffi_value: <u64 as proc_macro_runtime_interface::RIType>::FFIType,
                    | -> std::result::Result<
                        (),
                        proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error,
                    > {
                        T::with_function_context(
                            caller,
                            move |__function_context__| {
                                let result = std::panic::catch_unwind(
                                    std::panic::AssertUnwindSafe(|| {
                                        ExtWasmTracingExitVersion1::call(
                                                __function_context__,
                                                span_ffi_value,
                                            )
                                            .map_err(
                                                proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg,
                                            )
                                    }),
                                );
                                match result {
                                    Ok(result) => result,
                                    Err(panic) => {
                                        let message = if let Some(message)
                                            = panic.downcast_ref::<String>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else if let Some(message)
                                            = panic.downcast_ref::<&'static str>()
                                        {
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "host code panicked while being called by the runtime: {0}",
                                                        message,
                                                    ),
                                                );
                                                res
                                            }
                                        } else {
                                            "host code panicked while being called by the runtime"
                                                .to_owned()
                                        };
                                        return Err(
                                            proc_macro_runtime_interface::sp_wasm_interface::anyhow::Error::msg(
                                                message,
                                            ),
                                        );
                                    }
                                }
                            },
                        )
                    },
                )?;
            Ok(())
        }
    }
}
#[cfg(not(all(not(feature = "std"), feature = "with-tracing")))]
mod tracing_setup {
    /// Initialize tracing of sp_tracing not necessary  noop. To enable build
    /// without std and with the `with-tracing`-feature.
    pub fn init_tracing() {}
}
pub use tracing_setup::init_tracing;
/// Type alias for Externalities implementation used in tests.
#[cfg(feature = "std")]
pub type TestExternalities = sp_state_machine::TestExternalities<sp_core::Blake2Hasher>;
/// The host functions Substrate provides for the Wasm runtime environment.
///
/// All these host functions will be callable from inside the Wasm environment.
#[cfg(feature = "std")]
pub type SubstrateHostFunctions = (
    storage::HostFunctions,
    default_child_storage::HostFunctions,
    misc::HostFunctions,
    wasm_tracing::HostFunctions,
    offchain::HostFunctions,
    crypto::HostFunctions,
    hashing::HostFunctions,
    allocator::HostFunctions,
    panic_handler::HostFunctions,
    logging::HostFunctions,
    crate::trie::HostFunctions,
    offchain_index::HostFunctions,
    transaction_index::HostFunctions,
);
